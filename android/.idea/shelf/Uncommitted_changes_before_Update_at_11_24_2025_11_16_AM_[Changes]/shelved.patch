Index: ../client/src/App.tsx
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import { Switch, Route, useLocation, Router as WouterRouter } from \"wouter\";\r\nimport { useHashLocation } from \"wouter/use-hash-location\";\r\nimport { queryClient } from \"./lib/queryClient\";\r\nimport { QueryClientProvider } from \"@tanstack/react-query\";\r\nimport { Toaster } from \"@/components/ui/toaster\";\r\nimport { TooltipProvider } from \"@/components/ui/tooltip\";\r\nimport { SidebarProvider, SidebarTrigger } from \"@/components/ui/sidebar\";\r\nimport { AppSidebar } from \"@/components/app-sidebar\";\r\nimport { ThemeProvider } from \"@/components/theme-provider\";\r\nimport { ThemeToggle } from \"@/components/theme-toggle\";\r\nimport { UILanguageSelector } from \"@/components/ui-language-selector\";\r\nimport { GlobalSearchButton } from \"@/components/global-search-button\";\r\nimport { useAuth } from \"@/hooks/useAuth\";\r\nimport Home from \"@/pages/home\";\r\nimport Landing from \"@/pages/landing\";\r\nimport Login from \"@/pages/login\";\r\nimport Profile from \"@/pages/profile\";\r\nimport Pricing from \"@/pages/pricing\";\r\nimport Account from \"@/pages/account\";\r\nimport Checkout from \"@/pages/checkout\";\r\nimport CheckoutReturn from \"@/pages/checkout-return\";\r\nimport Library from \"@/pages/library\";\r\nimport PracticeStats from \"@/pages/practice-stats\";\r\nimport Terms from \"@/pages/terms\";\r\nimport NotFound from \"@/pages/not-found\";\r\nimport { Footer } from \"@/components/footer\";\r\nimport \"@/i18n/config\";\r\n\r\nfunction Router() {\r\n  const { isAuthenticated, isLoading } = useAuth();\r\n  const [location] = useLocation();\r\n\r\n  if (isLoading) {\r\n    return (\r\n      <div className=\"flex items-center justify-center h-screen\">\r\n        <div className=\"text-center space-y-4\">\r\n          <div className=\"h-8 w-8 border-4 border-primary border-t-transparent rounded-full animate-spin mx-auto\"></div>\r\n          <p className=\"text-muted-foreground\">Loading...</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  // For unauthenticated users, show only public routes\r\n  if (!isAuthenticated) {\r\n    return (\r\n      <div className=\"flex flex-col min-h-screen\">\r\n        <div className=\"flex-1\">\r\n          <Switch>\r\n            <Route path=\"/pricing\" component={Pricing} />\r\n            <Route path=\"/terms\" component={Terms} />\r\n            <Route path=\"/auth/login\" component={Login} />\r\n            <Route path=\"/\" component={Landing} />\r\n            <Route component={NotFound} />\r\n          </Switch>\r\n        </div>\r\n        <Footer />\r\n      </div>\r\n    );\r\n  }\r\n\r\n  // For authenticated users, show all routes\r\n  return (\r\n    <Switch>\r\n      <Route path=\"/pricing\" component={Pricing} />\r\n      <Route path=\"/terms\" component={Terms} />\r\n      <Route path=\"/auth/login\" component={Login} />\r\n      <Route path=\"/\" component={Home} />\r\n      <Route path=\"/library\" component={Library} />\r\n      <Route path=\"/practice-stats\" component={PracticeStats} />\r\n      <Route path=\"/account\" component={Account} />\r\n      <Route path=\"/profile\" component={Profile} />\r\n      <Route path=\"/checkout\" component={Checkout} />\r\n      <Route path=\"/checkout/return\" component={CheckoutReturn} />\r\n      <Route component={NotFound} />\r\n    </Switch>\r\n  );\r\n}\r\n\r\nfunction App() {\r\n  const style = {\r\n    \"--sidebar-width\": \"16rem\",\r\n    \"--sidebar-width-icon\": \"3rem\",\r\n  };\r\n\r\n  return (\r\n    <QueryClientProvider client={queryClient}>\r\n      <ThemeProvider defaultTheme=\"dark\">\r\n        <TooltipProvider>\r\n          <WouterRouter hook={useHashLocation}>\r\n            <AuthenticatedApp style={style} />\r\n          </WouterRouter>\r\n          <Toaster />\r\n        </TooltipProvider>\r\n      </ThemeProvider>\r\n    </QueryClientProvider>\r\n  );\r\n}\r\n\r\nfunction AuthenticatedApp({ style }: { style: Record<string, string> }) {\r\n  const { isAuthenticated, isLoading } = useAuth();\r\n  const [location] = useLocation();\r\n  const isHomePage = location === \"/\";\r\n\r\n  if (isLoading || !isAuthenticated) {\r\n    return <Router />;\r\n  }\r\n\r\n  return (\r\n    <SidebarProvider style={style as React.CSSProperties}>\r\n      <div className=\"flex h-screen w-full\">\r\n        <AppSidebar />\r\n        <div className=\"flex flex-col flex-1 overflow-hidden\">\r\n          <header className=\"flex items-center justify-between px-4 py-3 border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60\">\r\n            <div className=\"flex items-center gap-2\">\r\n              <SidebarTrigger data-testid=\"button-sidebar-toggle\" />\r\n              {!isHomePage && <GlobalSearchButton />}\r\n            </div>\r\n            <div className=\"flex items-center gap-2\">\r\n              <UILanguageSelector />\r\n              <ThemeToggle />\r\n            </div>\r\n          </header>\r\n          <main className=\"flex-1 overflow-auto flex flex-col\">\r\n            <div className=\"flex-1\">\r\n              <Router />\r\n            </div>\r\n            <Footer />\r\n          </main>\r\n        </div>\r\n      </div>\r\n    </SidebarProvider>\r\n  );\r\n}\r\n\r\nexport default App;\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../client/src/App.tsx b/../client/src/App.tsx
--- a/../client/src/App.tsx	(revision 9b9dda4a5767c994ce1eed3dade5009c7b928a8c)
+++ b/../client/src/App.tsx	(date 1763962802895)
@@ -1,6 +1,6 @@
 import { Switch, Route, useLocation, Router as WouterRouter } from "wouter";
 import { useHashLocation } from "wouter/use-hash-location";
-import { queryClient } from "./lib/queryClient";
+import { queryClient, setGuestUserId } from "./lib/queryClient"; // Import setGuestUserId
 import { QueryClientProvider } from "@tanstack/react-query";
 import { Toaster } from "@/components/ui/toaster";
 import { TooltipProvider } from "@/components/ui/tooltip";
@@ -26,6 +26,17 @@
 import { Footer } from "@/components/footer";
 import "@/i18n/config";
 
+// --- Guest User Initialization ---
+// On app startup, check for stored guest ID
+function initAuth() {
+  const storedGuestId = localStorage.getItem('guestUserId');
+  if (storedGuestId) {
+    setGuestUserId(storedGuestId);
+  }
+}
+initAuth(); // Run this logic once on app load
+// --- End Guest User Initialization ---
+
 function Router() {
   const { isAuthenticated, isLoading } = useAuth();
   const [location] = useLocation();
Index: ../client/src/hooks/useAuth.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import { useQuery } from \"@tanstack/react-query\";\r\nimport { getQueryFn } from \"@/lib/queryClient\";\r\n\r\ninterface AuthUser {\r\n  id: string;\r\n  email?: string;\r\n  username?: string;\r\n  firstName?: string;\r\n  lastName?: string;\r\n  profileImageUrl?: string;\r\n  isPremium?: boolean;\r\n  isGuest?: boolean;\r\n  authProvider?: string;\r\n  createdAt?: string;\r\n  country?: string;\r\n}\r\n\r\nexport function useAuth() {\r\n  const { data: user, isLoading } = useQuery<AuthUser | null>({\r\n    queryKey: [\"/api/auth/user\"],\r\n    queryFn: getQueryFn({ on401: \"returnNull\" }),\r\n    retry: false,\r\n  });\r\n\r\n  return {\r\n    user: user as AuthUser | undefined,\r\n    isLoading,\r\n    isAuthenticated: !!user,\r\n  };\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../client/src/hooks/useAuth.ts b/../client/src/hooks/useAuth.ts
--- a/../client/src/hooks/useAuth.ts	(revision 9b9dda4a5767c994ce1eed3dade5009c7b928a8c)
+++ b/../client/src/hooks/useAuth.ts	(date 1763963201269)
@@ -1,5 +1,5 @@
-import { useQuery } from "@tanstack/react-query";
-import { getQueryFn } from "@/lib/queryClient";
+import { useQuery, useQueryClient } from "@tanstack/react-query";
+import { getQueryFn, apiRequest, setGuestUserId } from "@/lib/queryClient";
 
 interface AuthUser {
   id: string;
@@ -16,15 +16,35 @@
 }
 
 export function useAuth() {
+  const queryClient = useQueryClient();
   const { data: user, isLoading } = useQuery<AuthUser | null>({
     queryKey: ["/api/auth/user"],
     queryFn: getQueryFn({ on401: "returnNull" }),
     retry: false,
   });
 
+  async function loginAsGuest() {
+    try {
+      const response: any = await apiRequest('POST', '/api/auth/guest');
+      if (response && response.user) {
+        setGuestUserId(response.user.id);
+        // Store in localStorage for persistence
+        localStorage.setItem('guestUserId', response.user.id);
+        
+        // Invalidate the user query to refetch and update auth state
+        await queryClient.invalidateQueries({ queryKey: ['/api/auth/user'] });
+      }
+      return response;
+    } catch (error) {
+      console.error('Guest login failed:', error);
+      throw error;
+    }
+  }
+
   return {
     user: user as AuthUser | undefined,
     isLoading,
     isAuthenticated: !!user,
+    loginAsGuest, // Expose the new function
   };
 }
Index: ../client/src/lib/queryClient.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import { QueryClient, QueryFunction } from \"@tanstack/react-query\";\r\n\r\nasync function throwIfResNotOk(res: Response) {\r\n  if (!res.ok) {\r\n    const text = (await res.text()) || res.statusText;\r\n    throw new Error(`${res.status}: ${text}`);\r\n  }\r\n}\r\n\r\n// Detect if running in Capacitor (mobile app)\r\nconst isCapacitor = !!(window as any).Capacitor;\r\n\r\n// Get backend URL - use lyricsensei.com for production, same origin for web\r\nconst getBackendUrl = () => {\r\n  // For Android/Capacitor, use the verified custom domain\r\n  if (isCapacitor) {\r\n    return \"https://lyricsensei.com\";\r\n  }\r\n  \r\n  // For web, use current origin (same server)\r\n  return window.location.origin;\r\n};\r\n\r\nconst BACKEND_URL = getBackendUrl();\r\n\r\nexport async function apiRequest<T = unknown>(\r\n  method: string,\r\n  url: string,\r\n  data?: unknown | undefined,\r\n): Promise<T> {\r\n  // For Capacitor (Android), use the custom domain\r\n  // For web browser, use relative URL (same origin)\r\n  const fullUrl = isCapacitor && !url.startsWith(\"http\") \r\n    ? `${BACKEND_URL}${url}`\r\n    : url;\r\n  \r\n  const res = await fetch(fullUrl, {\r\n    method,\r\n    headers: data ? { \"Content-Type\": \"application/json\" } : {},\r\n    body: data ? JSON.stringify(data) : undefined,\r\n    credentials: \"include\",\r\n  });\r\n\r\n  await throwIfResNotOk(res);\r\n  return await res.json();\r\n}\r\n\r\ntype UnauthorizedBehavior = \"returnNull\" | \"throw\";\r\nexport const getQueryFn: <T>(options: {\r\n  on401: UnauthorizedBehavior;\r\n}) => QueryFunction<T> =\r\n  ({ on401: unauthorizedBehavior }) =>\r\n  async ({ queryKey }) => {\r\n    const url = queryKey.join(\"/\") as string;\r\n    // For Capacitor (Android), use the custom domain\r\n    // For web browser, use relative URL (same origin)\r\n    const fullUrl = isCapacitor && !url.startsWith(\"http\")\r\n      ? `${BACKEND_URL}${url}`\r\n      : url;\r\n    \r\n    const res = await fetch(fullUrl, {\r\n      credentials: \"include\",\r\n    });\r\n\r\n    if (unauthorizedBehavior === \"returnNull\" && res.status === 401) {\r\n      return null;\r\n    }\r\n\r\n    await throwIfResNotOk(res);\r\n    return await res.json();\r\n  };\r\n\r\nexport const queryClient = new QueryClient({\r\n  defaultOptions: {\r\n    queries: {\r\n      queryFn: getQueryFn({ on401: \"throw\" }),\r\n      refetchInterval: false,\r\n      refetchOnWindowFocus: false,\r\n      staleTime: Infinity,\r\n      retry: false,\r\n    },\r\n    mutations: {\r\n      retry: false,\r\n    },\r\n  },\r\n});\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../client/src/lib/queryClient.ts b/../client/src/lib/queryClient.ts
--- a/../client/src/lib/queryClient.ts	(revision 9b9dda4a5767c994ce1eed3dade5009c7b928a8c)
+++ b/../client/src/lib/queryClient.ts	(date 1763962499575)
@@ -7,6 +7,19 @@
   }
 }
 
+// --- Guest User ID Management ---
+let guestUserId: string | null = null;
+
+export function setGuestUserId(id: string) {
+  guestUserId = id;
+}
+
+export function getGuestUserId() {
+  return guestUserId;
+}
+// --- End Guest User ID Management ---
+
+
 // Detect if running in Capacitor (mobile app)
 const isCapacitor = !!(window as any).Capacitor;
 
@@ -34,40 +47,76 @@
     ? `${BACKEND_URL}${url}`
     : url;
   
-  const res = await fetch(fullUrl, {
-    method,
-    headers: data ? { "Content-Type": "application/json" } : {},
-    body: data ? JSON.stringify(data) : undefined,
-    credentials: "include",
-  });
+  console.log(`[API Request] ${method} ${fullUrl}`);
+  
+  try {
+    const headers: Record<string, string> = {
+      ...(data ? { "Content-Type": "application/json" } : {}),
+      "Accept": "application/json",
+    };
+    
+    // Add guest ID header if available
+    if (guestUserId) {
+      headers['X-Guest-Id'] = guestUserId;
+    }
+
+    const res = await fetch(fullUrl, {
+      method,
+      headers,
+      body: data ? JSON.stringify(data) : undefined,
+      credentials: "include",
+      mode: "cors",
+    });
 
-  await throwIfResNotOk(res);
-  return await res.json();
+    console.log(`[API Response] ${res.status} ${res.statusText}`);
+    await throwIfResNotOk(res);
+    return await res.json();
+  } catch (error) {
+    console.error(`[API Error] ${method} ${fullUrl}:`, error);
+    throw error;
+  }
 }
 
 type UnauthorizedBehavior = "returnNull" | "throw";
 export const getQueryFn: <T>(options: {
   on401: UnauthorizedBehavior;
-}) => QueryFunction<T> =
+}) => QueryFunction<T> = 
   ({ on401: unauthorizedBehavior }) =>
   async ({ queryKey }) => {
     const url = queryKey.join("/") as string;
-    // For Capacitor (Android), use the custom domain
-    // For web browser, use relative URL (same origin)
     const fullUrl = isCapacitor && !url.startsWith("http")
       ? `${BACKEND_URL}${url}`
       : url;
     
-    const res = await fetch(fullUrl, {
-      credentials: "include",
-    });
+    console.log(`[API Request] GET ${fullUrl}`);
+    
+    try {
+      const headers: Record<string, string> = {
+        "Accept": "application/json",
+      };
+      
+      if (guestUserId) {
+        headers['X-Guest-Id'] = guestUserId;
+      }
+      
+      const res = await fetch(fullUrl, {
+        headers,
+        credentials: "include",
+        mode: "cors",
+      });
+
+      console.log(`[API Response] ${res.status} ${res.statusText}`);
 
-    if (unauthorizedBehavior === "returnNull" && res.status === 401) {
-      return null;
-    }
+      if (unauthorizedBehavior === "returnNull" && res.status === 401) {
+        return null;
+      }
 
-    await throwIfResNotOk(res);
-    return await res.json();
+      await throwIfResNotOk(res);
+      return await res.json();
+    } catch (error) {
+      console.error(`[API Error] GET ${fullUrl}:`, error);
+      throw error;
+    }
   };
 
 export const queryClient = new QueryClient({
Index: ../server/routes.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import type { Express } from \"express\";\r\nimport { createServer, type Server } from \"http\";\r\nimport { randomBytes } from \"crypto\";\r\nimport Stripe from \"stripe\";\r\nimport passport from \"passport\";\r\nimport bcrypt from \"bcryptjs\";\r\nimport { storage } from \"./storage\";\r\nimport { batchTranslateLyrics, detectLanguage } from \"./azure-translator\";\r\nimport { setupAuth, isAuthenticated } from \"./replitAuth\";\r\nimport { getACRCloudClient } from \"./acrcloud\";\r\nimport { fetchLyricsFromLrcLib } from \"./lrclib\";\r\nimport { getTrackDetails } from \"./spotify\";\r\nimport { searchITunes, searchITunesTracks } from \"./itunes\";\r\nimport {\r\n  translateLyricsRequestSchema,\r\n  recognizeSongRequestSchema,\r\n  updateUserProfileSchema,\r\n  manualSelectSongSchema,\r\n  updatePracticeStatsSchema,\r\n  type RecognitionResult,\r\n  type User,\r\n} from \"@shared/schema\";\r\nimport { ZodError, z } from \"zod\";\r\n\r\nif (!process.env.STRIPE_SECRET_KEY) {\r\n  throw new Error('Missing required Stripe secret: STRIPE_SECRET_KEY');\r\n}\r\nif (!process.env.STRIPE_PRICE_ID) {\r\n  throw new Error('Missing required Stripe secret: STRIPE_PRICE_ID');\r\n}\r\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY);\r\n\r\nexport async function registerRoutes(app: Express): Promise<Server> {\r\n  // Setup authentication - NEW MULTI-PROVIDER AUTH\r\n  const { setupNewAuth } = await import(\"./auth\");\r\n  await setupNewAuth(app);\r\n\r\n  // New auth endpoint - get current user (updated for new auth system)\r\n  app.get(\"/api/auth/user\", (req: any, res) => {\r\n    if (!req.user) {\r\n      return res.status(401).json({ error: \"Not authenticated\" });\r\n    }\r\n    res.json(req.user);\r\n  });\r\n\r\n  // OLD - Keep for backward compatibility but won't be used\r\n  // Auth endpoint - get current user\r\n  app.get(\"/api/auth/user-old\", isAuthenticated, async (req: any, res) => {\r\n    try {\r\n      const userId = (req.user as any).id || (req.user as any).claims?.sub;\r\n      const user = await storage.getUser(userId);\r\n      res.json(user);\r\n    } catch (error) {\r\n      console.error(\"Error fetching user:\", error);\r\n      res.status(500).json({ message: \"Failed to fetch user\" });\r\n    }\r\n  });\r\n\r\n  // Update user profile\r\n  app.put('/api/user/profile', isAuthenticated, async (req: any, res) => {\r\n    try {\r\n      const userId = (req.user as any).id || (req.user as any).claims?.sub;\r\n      const validated = updateUserProfileSchema.parse(req.body);\r\n      \r\n      const updatedUser = await storage.updateUserProfile(userId, validated);\r\n      \r\n      if (!updatedUser) {\r\n        return res.status(404).json({ error: \"User not found\" });\r\n      }\r\n      \r\n      res.json(updatedUser);\r\n    } catch (error) {\r\n      console.error(\"Error updating user profile:\", error);\r\n      \r\n      if (error instanceof ZodError) {\r\n        return res.status(400).json({ \r\n          error: \"Invalid profile data\",\r\n          details: error.errors \r\n        });\r\n      }\r\n      \r\n      if (error instanceof Error) {\r\n        const pgError = error as any;\r\n        if (pgError.code === '23505' || error.message.includes('unique constraint')) {\r\n          return res.status(409).json({ error: \"Username already taken\" });\r\n        }\r\n      }\r\n      \r\n      res.status(500).json({ error: \"Failed to update profile\" });\r\n    }\r\n  });\r\n\r\n  // Reset daily translation count (for testing purposes)\r\n  app.post('/api/user/reset-translations', isAuthenticated, async (req: any, res) => {\r\n    try {\r\n      const userId = (req.user as any).id || (req.user as any).claims?.sub;\r\n      const user = await storage.getUser(userId);\r\n\r\n      if (!user) {\r\n        return res.status(404).json({ error: \"User not found\" });\r\n      }\r\n\r\n      // Reset the translation count to 0\r\n      await storage.updateUserTranslationCount(user.id, 0, new Date().toISOString());\r\n\r\n      res.json({ success: true, message: \"Translation count reset successfully\" });\r\n    } catch (error) {\r\n      console.error(\"Error resetting translations:\", error);\r\n      res.status(500).json({ error: \"Failed to reset translation count\" });\r\n    }\r\n  });\r\n\r\n  // Google OAuth routes\r\n  // Initiate Google OAuth\r\n  app.get('/auth/google', passport.authenticate('google', { \r\n    scope: ['profile', 'email'] \r\n  }));\r\n\r\n  // Google OAuth callback\r\n  app.get('/api/auth/google/callback', \r\n    passport.authenticate('google', { failureRedirect: '/#/auth/login' }),\r\n    (req: any, res) => {\r\n      // Redirect to home page after successful login\r\n      res.redirect('/#/');\r\n    }\r\n  );\r\n\r\n  // Apple OAuth routes\r\n  app.get('/auth/apple', passport.authenticate('apple', {\r\n    scope: ['name', 'email']\r\n  }));\r\n\r\n  app.get('/api/auth/apple/callback',\r\n    passport.authenticate('apple', { failureRedirect: '/#/auth/login' }),\r\n    (req: any, res) => {\r\n      res.redirect('/#/');\r\n    }\r\n  );\r\n\r\n  // Facebook OAuth routes\r\n  app.get('/auth/facebook', passport.authenticate('facebook', {\r\n    scope: ['email', 'public_profile']\r\n  }));\r\n\r\n  app.get('/api/auth/facebook/callback',\r\n    passport.authenticate('facebook', { failureRedirect: '/#/auth/login' }),\r\n    (req: any, res) => {\r\n      res.redirect('/#/');\r\n    }\r\n  );\r\n\r\n  // Twitter OAuth routes\r\n  app.get('/auth/twitter', passport.authenticate('twitter'));\r\n\r\n  app.get('/api/auth/twitter/callback',\r\n    passport.authenticate('twitter', { failureRedirect: '/#/auth/login' }),\r\n    (req: any, res) => {\r\n      res.redirect('/#/');\r\n    }\r\n  );\r\n\r\n  // Login route - password-based auth\r\n  app.post('/api/auth/login', async (req: any, res, next) => {\r\n    passport.authenticate('local', (err: any, user: any, info: any) => {\r\n      if (err) {\r\n        return res.status(500).json({ error: 'Authentication error' });\r\n      }\r\n      if (!user) {\r\n        return res.status(401).json({ error: info?.message || 'Invalid credentials' });\r\n      }\r\n      req.logIn(user, (err: any) => {\r\n        if (err) {\r\n          return res.status(500).json({ error: 'Login failed' });\r\n        }\r\n        res.json({ user });\r\n      });\r\n    })(req, res, next);\r\n  });\r\n\r\n  // Signup route\r\n  app.post('/api/auth/signup', async (req: any, res) => {\r\n    try {\r\n      const { email, password, username, firstName, lastName } = req.body;\r\n\r\n      if (!email || !password || !username) {\r\n        return res.status(400).json({ error: 'Email, password, and username are required' });\r\n      }\r\n\r\n      // Check if user already exists\r\n      const existingUser = await storage.getUserByEmail(email);\r\n      if (existingUser) {\r\n        return res.status(409).json({ error: 'Email already registered' });\r\n      }\r\n\r\n      // Hash password\r\n      const passwordHash = await bcrypt.hash(password, 10);\r\n\r\n      // Create user\r\n      const user = await storage.createUser({\r\n        id: randomBytes(16).toString('hex'),\r\n        email,\r\n        passwordHash,\r\n        username,\r\n        firstName,\r\n        lastName,\r\n        authProvider: 'password',\r\n        isGuest: false,\r\n      });\r\n\r\n      // Log in the user\r\n      req.logIn(user, (err: any) => {\r\n        if (err) {\r\n          return res.status(500).json({ error: 'Signup failed' });\r\n        }\r\n        res.json({ user });\r\n      });\r\n    } catch (error) {\r\n      console.error('Signup error:', error);\r\n      res.status(500).json({ error: 'Signup failed' });\r\n    }\r\n  });\r\n\r\n  // Guest mode route\r\n  app.post('/api/auth/guest', async (req: any, res) => {\r\n    try {\r\n      // Create a guest user\r\n      const guestUser = await storage.createUser({\r\n        id: randomBytes(16).toString('hex'),\r\n        email: `guest-${Date.now()}@lyricsensei.local`,\r\n        username: `Guest_${Math.random().toString(36).substring(7)}`,\r\n        authProvider: 'guest',\r\n        isGuest: true,\r\n      });\r\n\r\n      // Log in the guest user\r\n      req.logIn(guestUser, (err: any) => {\r\n        if (err) {\r\n          return res.status(500).json({ error: 'Guest login failed' });\r\n        }\r\n        res.json({ user: guestUser });\r\n      });\r\n    } catch (error) {\r\n      console.error('Guest login error:', error);\r\n      res.status(500).json({ error: 'Guest login failed' });\r\n    }\r\n  });\r\n\r\n  // Logout route\r\n  app.post('/api/auth/logout', (req: any, res) => {\r\n    req.logOut((err: any) => {\r\n      if (err) {\r\n        return res.status(500).json({ error: 'Logout failed' });\r\n      }\r\n      res.json({ success: true });\r\n    });\r\n  });\r\n\r\n  // Search for songs using iTunes API (MUST come before :id route)\r\n  app.get(\"/api/songs/search\", async (req, res) => {\r\n    try {\r\n      const query = req.query.q as string;\r\n      \r\n      if (!query || query.trim().length === 0) {\r\n        return res.status(400).json({ error: \"Search query is required\" });\r\n      }\r\n\r\n      if (query.trim().length < 2) {\r\n        return res.status(400).json({ error: \"Search query must be at least 2 characters\" });\r\n      }\r\n\r\n      console.log('[API] Searching for tracks:', query);\r\n      \r\n      const results = await searchITunesTracks(query, 20);\r\n      \r\n      res.json({ results });\r\n    } catch (error) {\r\n      console.error(\"Error searching songs:\", error);\r\n      res.status(500).json({ error: \"Failed to search songs\" });\r\n    }\r\n  });\r\n\r\n  // Get top researched songs (MUST come before :id route)\r\n  app.get(\"/api/songs/top-researched\", async (_req, res) => {\r\n    try {\r\n      const topSongs = await storage.getTopResearchedSongs(10);\r\n      res.json(topSongs);\r\n    } catch (error) {\r\n      console.error(\"Error fetching top researched songs:\", error);\r\n      res.status(500).json({ error: \"Failed to fetch top researched songs\" });\r\n    }\r\n  });\r\n\r\n  // Get all songs\r\n  app.get(\"/api/songs\", async (_req, res) => {\r\n    try {\r\n      const songs = await storage.getAllSongs();\r\n      res.json(songs);\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  });\r\n\r\n  // Get song by ID (MUST come after /search and /top-researched routes)\r\n  app.get(\"/api/songs/:id\", async (req, res) => {\r\n    try {\r\n      const song = await storage.getSong(req.params.id);\r\n      if (!song) {\r\n        return res.status(404).json({ error: \"Song not found\" });\r\n      }\r\n      res.json(song);\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  });\r\n\r\n  // Manually select a song from search results\r\n  app.post(\"/api/songs/manual-select\", isAuthenticated, async (req: any, res) => {\r\n    try {\r\n      // Validate request body with Zod schema\r\n      const validatedData = manualSelectSongSchema.parse(req.body);\r\n      const { artist, title, album, albumArt, duration } = validatedData;\r\n\r\n      const userId = (req.user as any).id || (req.user as any).claims?.sub;\r\n\r\n      console.log('[Manual Select] Creating song:', title, 'by', artist);\r\n\r\n      // Find or create song in database\r\n      const song = await storage.findOrCreateSongByMetadata(\r\n        title,\r\n        artist,\r\n        album || title, // Use title as album if not provided\r\n        albumArt,\r\n        duration ?? 180 // Default duration if not provided (handles 0 correctly)\r\n      );\r\n\r\n      // Fetch and save lyrics from LrcLib (async)\r\n      fetchLyricsFromLrcLib(\r\n        title,\r\n        artist,\r\n        album || title,\r\n        song.duration\r\n      ).then(async (lyricsResult) => {\r\n        if (lyricsResult && lyricsResult.lyrics.length > 0) {\r\n          console.log('[Manual Select] Saving', lyricsResult.lyrics.length, 'lyrics lines for song:', song.id);\r\n          \r\n          const lyricLines = lyricsResult.lyrics.map((lyric, index) => ({\r\n            id: `${song.id}-${index}`,\r\n            startTime: lyric.startTime,\r\n            endTime: lyricsResult.lyrics[index + 1]?.startTime || song.duration,\r\n            text: lyric.text,\r\n          }));\r\n          \r\n          await storage.saveLyrics(song.id, lyricLines);\r\n          await storage.updateSong(song.id, { hasSyncedLyrics: lyricsResult.isSynced });\r\n          \r\n          // Detect language from lyrics (async, fire-and-forget)\r\n          const sampleText = lyricLines.slice(0, 3).map(l => l.text).join(' ');\r\n          detectLanguage(sampleText)\r\n            .then(detectedLang => {\r\n              return storage.updateSong(song.id, { detectedLanguage: detectedLang });\r\n            })\r\n            .then(() => {\r\n              console.log('[Manual Select] Language detection completed');\r\n            })\r\n            .catch(langError => {\r\n              console.error('[Manual Select] Language detection failed (background):', langError);\r\n            });\r\n        }\r\n      }).catch((error) => {\r\n        console.error('[Manual Select] Failed to fetch lyrics:', error);\r\n      });\r\n\r\n      // Save to recognition history and get the server-side timestamp\r\n      const historyRecord = await storage.addRecognitionHistory({\r\n        userId,\r\n        songId: song.id,\r\n        confidence: 1.0, // Manual selection is always 100% confident\r\n      });\r\n\r\n      // Return RecognitionResult format matching frontend expectations\r\n      const result = {\r\n        songId: song.id,\r\n        title: song.title,\r\n        artist: song.artist,\r\n        album: song.album,\r\n        confidence: 1.0,\r\n        albumArt: song.albumArt,\r\n        previewOffsetSeconds: 0, // Manual selection starts from beginning\r\n        timestamp: new Date(historyRecord.recognizedAt).getTime(),\r\n      };\r\n\r\n      res.json(result);\r\n    } catch (error) {\r\n      // Handle validation errors\r\n      if (error instanceof ZodError) {\r\n        return res.status(400).json({ \r\n          error: \"Validation failed\", \r\n          details: error.errors \r\n        });\r\n      }\r\n      console.error(\"Error in manual song selection:\", error);\r\n      res.status(500).json({ error: \"Failed to select song\" });\r\n    }\r\n  });\r\n\r\n  // Get lyrics for a song\r\n  app.get(\"/api/lyrics/:songId\", async (req, res) => {\r\n    try {\r\n      const lyrics = await storage.getLyrics(req.params.songId);\r\n      res.json(lyrics);\r\n    } catch (error) {\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  });\r\n\r\n  // Get translations for a song\r\n  app.get(\"/api/translations/:songId/:language\", async (req, res) => {\r\n    try {\r\n      const { songId, language } = req.params;\r\n      \r\n      // Get current lyrics (now properly ordered)\r\n      const lyrics = await storage.getLyrics(songId);\r\n      if (lyrics.length === 0) {\r\n        return res.status(404).json({ error: \"Lyrics not found\" });\r\n      }\r\n      \r\n      // Check if we have cached translations\r\n      let translations = await storage.getTranslations(songId, language);\r\n      \r\n      // Validate cached translations match current lyrics\r\n      if (translations.length > 0) {\r\n        console.log(`[Translation Cache] Found ${translations.length} cached translations for ${language}`);\r\n        console.log(`[Translation Cache] Sample phonetic: \"${translations[0]?.phoneticGuide}\"`);\r\n        \r\n        const isValid = translations.length === lyrics.length &&\r\n          translations.every((t, idx) => t.originalText === lyrics[idx].text);\r\n        \r\n        // Also check if phonetic guides are missing or same as original for languages that should have them\r\n        // NOTE: Check SOURCE language (from cached translation), not target language parameter\r\n        const sourceLanguage = translations[0]?.sourceLanguage;\r\n        \r\n        // Normalize language code to base language (e.g., \"pt-BR\" → \"pt\")\r\n        const baseLang = sourceLanguage?.split('-')[0];\r\n        \r\n        // Languages requiring custom phonetic generation (Latin scripts with special rules)\r\n        const phonetic_languages = ['es', 'fr', 'pt', 'de', 'pa', 'hi', 'zu', 'xh'];\r\n        \r\n        // Check if phonetics are needed AND missing/invalid\r\n        const needsPhonetics = baseLang && phonetic_languages.includes(baseLang);\r\n        const hasMissingPhonetics = translations.some(t => \r\n          !t.phoneticGuide || \r\n          t.phoneticGuide.trim() === '' ||\r\n          t.phoneticGuide === t.originalText || // Phonetic same as original = not processed\r\n          t.phoneticGuide === t.translatedText   // Phonetic same as translation = not processed\r\n        );\r\n        \r\n        // Regenerate if source language needs phonetics OR if sourceLanguage is missing (legacy cache)\r\n        const shouldRegenerate = (needsPhonetics && hasMissingPhonetics) || !sourceLanguage;\r\n        \r\n        if (!isValid || shouldRegenerate) {\r\n          if (!isValid) {\r\n            console.log(`[Translation Cache] Mismatch detected for song ${songId} (${language}). Purging cache.`);\r\n            console.log(`  - Lyrics count: ${lyrics.length}, Translations count: ${translations.length}`);\r\n          }\r\n          if (shouldRegenerate) {\r\n            if (!sourceLanguage) {\r\n              console.log(`[Translation Cache] Legacy cache missing sourceLanguage. Regenerating.`);\r\n            } else {\r\n              console.log(`[Translation Cache] Missing/invalid phonetics for ${baseLang}. Regenerating with phonetic guides.`);\r\n            }\r\n          }\r\n          \r\n          // Purge stale cache\r\n          await storage.saveTranslations(songId, language, []);\r\n          translations = [];\r\n        }\r\n      }\r\n      \r\n      if (translations.length === 0) {\r\n        // Check user authentication - but allow unauthenticated access with limitations\r\n        let userId: string | null = null;\r\n        if (req.isAuthenticated()) {\r\n          userId = (req.user as any).claims.sub;\r\n          \r\n          // Check daily translation limit for free users\r\n          const limitCheck = await storage.checkAndUpdateTranslationLimit(userId!);\r\n          \r\n          if (!limitCheck.allowed) {\r\n            return res.status(429).json({ \r\n              error: \"Daily translation limit reached. Upgrade to Premium for unlimited translations!\",\r\n              dailyLimitReached: true,\r\n              remaining: 0\r\n            });\r\n          }\r\n        }\r\n\r\n        // Generate new translations (lyrics already fetched above)\r\n        const lyricTexts = lyrics.map((line) => line.text);\r\n        \r\n        // Get song's detected language to use as source (prevents per-line auto-detection issues)\r\n        const song = await storage.getSong(songId);\r\n        const songLanguage = song?.detectedLanguage;\r\n        \r\n        try {\r\n          // Pass song's language as source to prevent Azure from mis-detecting each line\r\n          const translationResults = await batchTranslateLyrics(\r\n            lyricTexts, \r\n            language, \r\n            songLanguage && songLanguage !== 'unknown' ? songLanguage : undefined\r\n          );\r\n          \r\n          translations = translationResults.map((result) => ({\r\n            ...result,\r\n            targetLanguage: language,\r\n          }));\r\n          \r\n          // Only persist detected language if song language is unknown (don't overwrite manually set languages)\r\n          if (translationResults.length > 0 && translationResults[0].sourceLanguage) {\r\n            const detectedLang = translationResults[0].sourceLanguage;\r\n            if (detectedLang !== 'unknown' && (!songLanguage || songLanguage === 'unknown')) {\r\n              await storage.updateSong(songId, { detectedLanguage: detectedLang });\r\n              console.log(`[Translation] Persisted detected language: ${detectedLang} for song ${songId} (was: ${songLanguage || 'null'})`);\r\n            }\r\n          }\r\n          \r\n          // Cache translations\r\n          await storage.saveTranslations(songId, language, translations);\r\n        } catch (translationError: any) {\r\n          console.error(\"Translation error:\", translationError);\r\n          \r\n          return res.status(503).json({ \r\n            error: \"Translation service is currently unavailable. Please try again later.\" \r\n          });\r\n        }\r\n      }\r\n      \r\n      // Debug: Log what we're returning\r\n      if (translations.length > 0) {\r\n        console.log(`[Translation API] Returning ${translations.length} translations`);\r\n        console.log(`[Translation API] Sample: \"${translations[0].originalText}\" → \"${translations[0].translatedText}\"`);\r\n        console.log(`[Translation API] Sample phonetic: \"${translations[0].phoneticGuide}\"`);\r\n      }\r\n      \r\n      res.json(translations);\r\n    } catch (error) {\r\n      console.error(\"Translation error:\", error);\r\n      res.status(500).json({ error: \"An unexpected error occurred while fetching translations.\" });\r\n    }\r\n  });\r\n\r\n  // Translate lyrics (manual translation endpoint)\r\n  app.post(\"/api/translate\", async (req, res) => {\r\n    try {\r\n      const validated = translateLyricsRequestSchema.parse(req.body);\r\n      const translations = await batchTranslateLyrics(\r\n        validated.lyrics,\r\n        validated.targetLanguage\r\n      );\r\n      res.json(translations);\r\n    } catch (error) {\r\n      res.status(400).json({ error: (error as Error).message });\r\n    }\r\n  });\r\n\r\n  // Health check endpoint - verify environment configuration\r\n  app.get(\"/api/health\", async (req, res) => {\r\n    const health = {\r\n      status: \"ok\",\r\n      environment: process.env.NODE_ENV || \"unknown\",\r\n      acrcloud: {\r\n        configured: !!(process.env.ACRCLOUD_ACCESS_KEY && process.env.ACRCLOUD_ACCESS_SECRET && process.env.ACRCLOUD_HOST),\r\n        accessKeySet: !!process.env.ACRCLOUD_ACCESS_KEY,\r\n        secretSet: !!process.env.ACRCLOUD_ACCESS_SECRET,\r\n        hostSet: !!process.env.ACRCLOUD_HOST,\r\n      },\r\n      azureTranslator: {\r\n        configured: !!(process.env.AZURE_TRANSLATOR_KEY && process.env.AZURE_TRANSLATOR_REGION),\r\n        keySet: !!process.env.AZURE_TRANSLATOR_KEY,\r\n        regionSet: !!process.env.AZURE_TRANSLATOR_REGION,\r\n      },\r\n      database: {\r\n        configured: !!process.env.DATABASE_URL,\r\n      },\r\n      session: {\r\n        configured: !!process.env.SESSION_SECRET,\r\n      },\r\n    };\r\n    \r\n    res.json(health);\r\n  });\r\n\r\n  // Recognize song using ACRCloud\r\n  app.post(\"/api/recognize\", async (req, res) => {\r\n    try {\r\n      const validated = recognizeSongRequestSchema.parse(req.body);\r\n      \r\n      // Check user authentication\r\n      if (!req.isAuthenticated()) {\r\n        return res.status(401).json({ error: \"Authentication required\" });\r\n      }\r\n\r\n      const userId = (req.user as any).claims.sub;\r\n      \r\n      // Use ACRCloud for real song recognition\r\n      try {\r\n        const acrcloud = getACRCloudClient();\r\n        const recognizedSong = await acrcloud.recognizeSong(validated.audioData);\r\n        \r\n        if (!recognizedSong) {\r\n          return res.status(404).json({ \r\n            error: \"Song not recognized. Please try recording a clearer sample or a different part of the song.\" \r\n          });\r\n        }\r\n\r\n        // Fetch album art and metadata from iTunes (free, no auth required)\r\n        let albumArtUrl = recognizedSong.albumArtUrl;\r\n        let actualDuration = recognizedSong.durationMs ? Math.round(recognizedSong.durationMs / 1000) : 180;\r\n        \r\n        try {\r\n          const itunesData = await searchITunes(\r\n            recognizedSong.artist,\r\n            recognizedSong.album,\r\n            recognizedSong.title\r\n          );\r\n          \r\n          if (itunesData) {\r\n            albumArtUrl = itunesData.artworkUrl;\r\n            console.log('[Recognition] Fetched album art from iTunes');\r\n            \r\n            if (itunesData.duration) {\r\n              actualDuration = itunesData.duration;\r\n              console.log('[Recognition] Using iTunes duration:', actualDuration, 'seconds');\r\n            }\r\n          }\r\n        } catch (err) {\r\n          console.error('[Recognition] Failed to fetch from iTunes:', err);\r\n        }\r\n        \r\n        // Fallback to Spotify if iTunes didn't work\r\n        if (!albumArtUrl && recognizedSong.spotifyTrackId) {\r\n          try {\r\n            const { albumArt } = await getTrackDetails(recognizedSong.spotifyTrackId);\r\n            if (albumArt) {\r\n              albumArtUrl = albumArt;\r\n              console.log('[Recognition] Fetched album art from Spotify (fallback)');\r\n            }\r\n          } catch (err) {\r\n            console.error('[Recognition] Failed to fetch from Spotify:', err);\r\n          }\r\n        }\r\n        \r\n        // Find or create song in database with accurate duration\r\n        const song = await storage.findOrCreateSongByMetadata(\r\n          recognizedSong.title,\r\n          recognizedSong.artist,\r\n          recognizedSong.album,\r\n          albumArtUrl,\r\n          actualDuration\r\n        );\r\n        \r\n        // Update song with preview offset if available\r\n        const updates: any = {};\r\n        if (recognizedSong.playOffsetMs !== undefined) {\r\n          updates.previewOffsetSeconds = Math.round(recognizedSong.playOffsetMs / 1000);\r\n          console.log('[Recognition] Updating song with preview offset:', updates.previewOffsetSeconds, 'seconds');\r\n        }\r\n        \r\n        if (Object.keys(updates).length > 0) {\r\n          await storage.updateSong(song.id, updates);\r\n        }\r\n        \r\n        // Fetch and save lyrics from LrcLib (don't wait for it)\r\n        fetchLyricsFromLrcLib(\r\n          recognizedSong.title,\r\n          recognizedSong.artist,\r\n          recognizedSong.album,\r\n          song.duration\r\n        ).then(async (lyricsResult) => {\r\n          if (lyricsResult && lyricsResult.lyrics.length > 0) {\r\n            console.log('[Recognition] Saving', lyricsResult.lyrics.length, 'lyrics lines for song:', song.id);\r\n            \r\n            // Convert parsed lyrics to LyricLine format\r\n            const lyricLines = lyricsResult.lyrics.map((lyric, index) => ({\r\n              id: `${song.id}-${index}`,\r\n              startTime: lyric.startTime,\r\n              endTime: lyricsResult.lyrics[index + 1]?.startTime || song.duration,\r\n              text: lyric.text,\r\n            }));\r\n            \r\n            await storage.saveLyrics(song.id, lyricLines);\r\n            await storage.updateSong(song.id, { hasSyncedLyrics: lyricsResult.isSynced });\r\n            console.log('[Recognition] Lyrics saved successfully (synced:', lyricsResult.isSynced, ')');\r\n            \r\n            // Detect language from lyrics (async, fire-and-forget)\r\n            if (lyricLines.length > 0) {\r\n              const sampleText = lyricLines.slice(0, 3).map(l => l.text).join(' ');\r\n              detectLanguage(sampleText)\r\n                .then(detectedLang => {\r\n                  return storage.updateSong(song.id, { detectedLanguage: detectedLang });\r\n                })\r\n                .then(() => {\r\n                  console.log('[Recognition] Language detection completed');\r\n                })\r\n                .catch(langError => {\r\n                  console.error('[Recognition] Language detection failed (background):', langError);\r\n                });\r\n            }\r\n          } else {\r\n            console.log('[Recognition] No lyrics available for this song');\r\n          }\r\n        }).catch(err => {\r\n          console.error('[Recognition] Error saving lyrics:', err);\r\n        });\r\n        \r\n        // Save to recognition history\r\n        await storage.addRecognitionHistory({\r\n          userId,\r\n          songId: song.id,\r\n          confidence: recognizedSong.confidence,\r\n        });\r\n        \r\n        const result: RecognitionResult = {\r\n          songId: song.id,\r\n          title: song.title,\r\n          artist: song.artist,\r\n          album: song.album ?? undefined,\r\n          albumArt: song.albumArt ?? undefined,\r\n          previewOffsetSeconds: updates.previewOffsetSeconds ?? undefined,\r\n          confidence: recognizedSong.confidence,\r\n          timestamp: Date.now(),\r\n        };\r\n\r\n        res.json(result);\r\n      } catch (acrError: any) {\r\n        console.error(\"ACRCloud recognition error:\", acrError);\r\n        \r\n        // Check if it's a configuration error\r\n        if (acrError.message?.includes(\"credentials not configured\")) {\r\n          return res.status(503).json({ \r\n            error: \"Song recognition service is not configured. Please contact support.\" \r\n          });\r\n        }\r\n        \r\n        // Check for specific ACRCloud error codes\r\n        if (acrError.message?.includes(\"2000\") || acrError.message?.includes(\"Invalid access\")) {\r\n          return res.status(503).json({ \r\n            error: \"Invalid API credentials. Please contact support.\" \r\n          });\r\n        }\r\n        \r\n        if (acrError.message?.includes(\"3000\") || acrError.message?.includes(\"Limit exceeded\")) {\r\n          return res.status(429).json({ \r\n            error: \"Daily recognition limit exceeded. Please try again tomorrow or upgrade to Premium.\" \r\n          });\r\n        }\r\n        \r\n        if (acrError.message?.includes(\"3001\") || acrError.message?.includes(\"Invalid signature\")) {\r\n          return res.status(503).json({ \r\n            error: \"Authentication error. Please contact support.\" \r\n          });\r\n        }\r\n        \r\n        if (acrError.message?.includes(\"3100\")) {\r\n          return res.status(503).json({ \r\n            error: \"Music recognition service is temporarily unavailable. Please try again in a moment.\" \r\n          });\r\n        }\r\n        \r\n        return res.status(500).json({ \r\n          error: \"Failed to recognize song. Please try again.\" \r\n        });\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Recognition endpoint error:\", error);\r\n      res.status(400).json({ error: (error as Error).message });\r\n    }\r\n  });\r\n\r\n  // Get user recognition history\r\n  app.get(\"/api/recognition-history\", async (req, res) => {\r\n    try {\r\n      if (!req.isAuthenticated()) {\r\n        return res.status(401).json({ error: \"Authentication required\" });\r\n      }\r\n\r\n      const userId = (req.user as any).id || (req.user as any).claims?.sub;\r\n      const limit = parseInt(req.query.limit as string) || 50;\r\n      \r\n      const history = await storage.getUserRecognitionHistory(userId, limit);\r\n      \r\n      // Get user favorites to mark them in history\r\n      const favorites = await storage.getUserFavorites(userId);\r\n      const favoriteSongIds = new Set(favorites.map(f => f.songId));\r\n      \r\n      // Transform to RecognitionResult format for frontend\r\n      const results: RecognitionResult[] = history.map(h => ({\r\n        songId: h.song.id,\r\n        title: h.song.title,\r\n        artist: h.song.artist,\r\n        album: h.song.album ?? undefined,\r\n        albumArt: h.song.albumArt ?? undefined,\r\n        previewOffsetSeconds: h.song.previewOffsetSeconds ?? undefined,\r\n        confidence: h.confidence,\r\n        timestamp: h.recognizedAt.getTime(),\r\n        isFavorite: favoriteSongIds.has(h.song.id),\r\n      }));\r\n      \r\n      res.json(results);\r\n    } catch (error) {\r\n      console.error(\"History fetch error:\", error);\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  });\r\n\r\n  // Get user favorites\r\n  app.get(\"/api/favorites\", isAuthenticated, async (req: any, res) => {\r\n    try {\r\n      const userId = (req.user as any).id || (req.user as any).claims?.sub;\r\n      const favorites = await storage.getUserFavorites(userId);\r\n      \r\n      // Transform to RecognitionResult format for frontend\r\n      const results: RecognitionResult[] = favorites.map(f => ({\r\n        songId: f.song.id,\r\n        title: f.song.title,\r\n        artist: f.song.artist,\r\n        album: f.song.album ?? undefined,\r\n        albumArt: f.song.albumArt ?? undefined,\r\n        previewOffsetSeconds: f.song.previewOffsetSeconds ?? undefined,\r\n        confidence: 1.0,\r\n        timestamp: f.createdAt.getTime(),\r\n        isFavorite: true,\r\n      }));\r\n      \r\n      res.json(results);\r\n    } catch (error) {\r\n      console.error(\"Favorites fetch error:\", error);\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  });\r\n\r\n  // Add song to favorites\r\n  app.post(\"/api/favorites/:songId\", isAuthenticated, async (req: any, res) => {\r\n    try {\r\n      const userId = (req.user as any).id || (req.user as any).claims?.sub;\r\n      const { songId } = req.params;\r\n      \r\n      // Check if song exists\r\n      const song = await storage.getSong(songId);\r\n      if (!song) {\r\n        return res.status(404).json({ error: \"Song not found\" });\r\n      }\r\n      \r\n      // Check if already favorited\r\n      const isAlreadyFavorite = await storage.isFavorite(userId, songId);\r\n      if (isAlreadyFavorite) {\r\n        return res.json({ message: \"Already favorited\" });\r\n      }\r\n      \r\n      await storage.addFavorite(userId, songId);\r\n      res.json({ message: \"Song added to favorites\" });\r\n    } catch (error) {\r\n      console.error(\"Add favorite error:\", error);\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  });\r\n\r\n  // Remove song from favorites\r\n  app.delete(\"/api/favorites/:songId\", isAuthenticated, async (req: any, res) => {\r\n    try {\r\n      const userId = (req.user as any).id || (req.user as any).claims?.sub;\r\n      const { songId } = req.params;\r\n      \r\n      await storage.removeFavorite(userId, songId);\r\n      res.json({ message: \"Song removed from favorites\" });\r\n    } catch (error) {\r\n      console.error(\"Remove favorite error:\", error);\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  });\r\n\r\n  // Check if song is favorited\r\n  app.get(\"/api/favorites/:songId/check\", isAuthenticated, async (req: any, res) => {\r\n    try {\r\n      const userId = (req.user as any).id || (req.user as any).claims?.sub;\r\n      const { songId } = req.params;\r\n      \r\n      const isFavorite = await storage.isFavorite(userId, songId);\r\n      res.json({ isFavorite });\r\n    } catch (error) {\r\n      console.error(\"Check favorite error:\", error);\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  });\r\n\r\n  // Practice Stats Routes\r\n  \r\n  // Update practice stats for a song\r\n  app.post(\"/api/practice-stats\", isAuthenticated, async (req: any, res) => {\r\n    try {\r\n      const userId = (req.user as any).id || (req.user as any).claims?.sub;\r\n      \r\n      // Validate request body using shared schema\r\n      const validationSchema = updatePracticeStatsSchema\r\n        .extend({\r\n          songId: z.string().min(1),\r\n        })\r\n        .refine(\r\n          (data) => data.successfulAttempts <= data.totalAttempts,\r\n          { message: \"Successful attempts cannot exceed total attempts\" }\r\n        );\r\n      \r\n      const validated = validationSchema.parse(req.body);\r\n      \r\n      const stats = await storage.updatePracticeStats(\r\n        userId,\r\n        validated.songId,\r\n        validated.totalAttempts,\r\n        validated.successfulAttempts\r\n      );\r\n      res.json(stats);\r\n    } catch (error) {\r\n      console.error(\"Update practice stats error:\", error);\r\n      \r\n      if (error instanceof z.ZodError) {\r\n        return res.status(400).json({ \r\n          error: \"Invalid request body\",\r\n          details: error.errors \r\n        });\r\n      }\r\n      \r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  });\r\n\r\n  // Get all practice stats for current user\r\n  app.get(\"/api/practice-stats\", isAuthenticated, async (req: any, res) => {\r\n    try {\r\n      const userId = (req.user as any).id || (req.user as any).claims?.sub;\r\n      const stats = await storage.getUserPracticeStats(userId);\r\n      res.json(stats);\r\n    } catch (error) {\r\n      console.error(\"Get practice stats error:\", error);\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  });\r\n\r\n  // Get practice stats for a specific song\r\n  app.get(\"/api/practice-stats/:songId\", isAuthenticated, async (req: any, res) => {\r\n    try {\r\n      const userId = (req.user as any).id || (req.user as any).claims?.sub;\r\n      const { songId } = req.params;\r\n      \r\n      const stats = await storage.getSongPracticeStats(userId, songId);\r\n      res.json(stats || null);\r\n    } catch (error) {\r\n      console.error(\"Get song practice stats error:\", error);\r\n      res.status(500).json({ error: (error as Error).message });\r\n    }\r\n  });\r\n\r\n  // Social media sharing endpoint - serves Open Graph meta tags\r\n  app.get(\"/share/:songId\", async (req, res) => {\r\n    try {\r\n      const { songId } = req.params;\r\n      const song = await storage.getSong(songId);\r\n      \r\n      if (!song) {\r\n        return res.redirect('/');\r\n      }\r\n      \r\n      const title = `${song.title} by ${song.artist} - LyricSync`;\r\n      const description = `Translate and learn the pronunciation of \"${song.title}\" in any language with LyricSync's AI-powered phonetic guides.`;\r\n      const imageUrl = song.albumArt || 'https://lyricsync.repl.co/icon-512.png';\r\n      \r\n      // Serve HTML with Open Graph meta tags for social crawlers\r\n      res.send(`\r\n        <!DOCTYPE html>\r\n        <html>\r\n          <head>\r\n            <meta charset=\"UTF-8\" />\r\n            <title>${title}</title>\r\n            <meta name=\"description\" content=\"${description}\" />\r\n            \r\n            <!-- Open Graph / Facebook -->\r\n            <meta property=\"og:type\" content=\"music.song\" />\r\n            <meta property=\"og:url\" content=\"${req.protocol}://${req.get('host')}/share/${songId}\" />\r\n            <meta property=\"og:title\" content=\"${title}\" />\r\n            <meta property=\"og:description\" content=\"${description}\" />\r\n            <meta property=\"og:image\" content=\"${imageUrl}\" />\r\n            <meta property=\"og:image:width\" content=\"1200\" />\r\n            <meta property=\"og:image:height\" content=\"630\" />\r\n            <meta property=\"og:site_name\" content=\"LyricSync\" />\r\n            \r\n            <!-- Twitter -->\r\n            <meta property=\"twitter:card\" content=\"summary_large_image\" />\r\n            <meta property=\"twitter:url\" content=\"${req.protocol}://${req.get('host')}/share/${songId}\" />\r\n            <meta property=\"twitter:title\" content=\"${title}\" />\r\n            <meta property=\"twitter:description\" content=\"${description}\" />\r\n            <meta property=\"twitter:image\" content=\"${imageUrl}\" />\r\n            \r\n            <!-- Redirect for normal navigation -->\r\n            <meta http-equiv=\"refresh\" content=\"0; url=/\" />\r\n            <script>\r\n              window.location.href = '/';\r\n            </script>\r\n          </head>\r\n          <body>\r\n            <p>Redirecting to LyricSync...</p>\r\n          </body>\r\n        </html>\r\n      `);\r\n    } catch (error) {\r\n      console.error(\"Share route error:\", error);\r\n      res.redirect('/');\r\n    }\r\n  });\r\n\r\n  // Stripe: Diagnostic endpoint to check price configuration\r\n  app.get('/api/stripe-price-check', isAuthenticated, async (req: any, res) => {\r\n    try {\r\n      const monthlyPriceId = process.env.STRIPE_PRICE_ID;\r\n      const yearlyPriceId = process.env.STRIPE_YEARLY_PRICE_ID;\r\n\r\n      const diagnostics: any = {\r\n        envVarsConfigured: {\r\n          monthly: !!monthlyPriceId,\r\n          yearly: !!yearlyPriceId,\r\n        },\r\n        prices: {},\r\n      };\r\n\r\n      if (monthlyPriceId) {\r\n        try {\r\n          const monthlyPrice = await stripe.prices.retrieve(monthlyPriceId, {\r\n            expand: ['product'],\r\n          });\r\n          const productData = monthlyPrice.product as any;\r\n          diagnostics.prices.monthly = {\r\n            id: monthlyPrice.id,\r\n            active: monthlyPrice.active,\r\n            type: monthlyPrice.type,\r\n            amount: monthlyPrice.unit_amount,\r\n            currency: monthlyPrice.currency,\r\n            recurring: monthlyPrice.recurring,\r\n            product: {\r\n              id: productData.id,\r\n              name: productData.name,\r\n              active: productData.active,\r\n              default_price: productData.default_price,\r\n            },\r\n          };\r\n        } catch (error: any) {\r\n          diagnostics.prices.monthly = { error: error.message };\r\n        }\r\n      }\r\n\r\n      if (yearlyPriceId) {\r\n        try {\r\n          const yearlyPrice = await stripe.prices.retrieve(yearlyPriceId, {\r\n            expand: ['product'],\r\n          });\r\n          const productData = yearlyPrice.product as any;\r\n          diagnostics.prices.yearly = {\r\n            id: yearlyPrice.id,\r\n            active: yearlyPrice.active,\r\n            type: yearlyPrice.type,\r\n            amount: yearlyPrice.unit_amount,\r\n            currency: yearlyPrice.currency,\r\n            recurring: yearlyPrice.recurring,\r\n            product: {\r\n              id: productData.id,\r\n              name: productData.name,\r\n              active: productData.active,\r\n              default_price: productData.default_price,\r\n            },\r\n          };\r\n        } catch (error: any) {\r\n          diagnostics.prices.yearly = { error: error.message };\r\n        }\r\n      }\r\n\r\n      res.json(diagnostics);\r\n    } catch (error: any) {\r\n      console.error(\"Price check error:\", error);\r\n      res.status(500).json({ error: error.message });\r\n    }\r\n  });\r\n\r\n  // Stripe: Create Checkout Session for subscription (Stripe-recommended approach)\r\n  app.post('/api/create-subscription', isAuthenticated, async (req: any, res) => {\r\n    try {\r\n      const userId = (req.user as any).id || (req.user as any).claims?.sub;\r\n      let user = await storage.getUser(userId);\r\n\r\n      if (!user) {\r\n        return res.status(404).json({ error: \"User not found\" });\r\n      }\r\n\r\n      // If user already has an active subscription, redirect to account page\r\n      if (user.stripeSubscriptionId) {\r\n        const subscription = await stripe.subscriptions.retrieve(user.stripeSubscriptionId);\r\n        \r\n        if (subscription.status === 'active' || subscription.status === 'trialing') {\r\n          return res.json({\r\n            subscriptionId: subscription.id,\r\n            status: subscription.status,\r\n            alreadySubscribed: true,\r\n          });\r\n        }\r\n      }\r\n\r\n      // Create a new customer if needed\r\n      if (!user.stripeCustomerId) {\r\n        const customer = await stripe.customers.create({\r\n          email: user.email ?? undefined,\r\n          name: `${user.firstName || ''} ${user.lastName || ''}`.trim() || undefined,\r\n          metadata: {\r\n            userId: user.id,\r\n          },\r\n        });\r\n\r\n        await storage.updateUserStripeInfo(user.id, customer.id);\r\n        user = await storage.getUser(userId);\r\n        if (!user) {\r\n          return res.status(500).json({ error: \"Failed to update user\" });\r\n        }\r\n      }\r\n\r\n      // Determine which price to use based on interval\r\n      const { interval = 'month' } = req.body; // 'month' or 'year'\r\n      const priceId = interval === 'year' \r\n        ? (process.env.STRIPE_YEARLY_PRICE_ID || process.env.STRIPE_PRICE_ID) \r\n        : process.env.STRIPE_PRICE_ID;\r\n\r\n      console.log(`[Stripe Checkout] Creating Checkout Session for user ${user.id}`);\r\n      console.log(`[Stripe Checkout] Interval: ${interval}`);\r\n      console.log(`[Stripe Checkout] Price ID: ${priceId ? priceId.substring(0, 15) + '...' : 'MISSING'}`);\r\n\r\n      if (!priceId) {\r\n        throw new Error(\"Stripe price ID is not configured. Please set STRIPE_PRICE_ID and STRIPE_YEARLY_PRICE_ID in environment variables.\");\r\n      }\r\n\r\n      // Build return URL for embedded checkout (preserve interval in query params)\r\n      const baseUrl = `${req.protocol}://${req.get('host')}`;\r\n      const returnUrl = `${baseUrl}/checkout/return?session_id={CHECKOUT_SESSION_ID}&interval=${interval}`;\r\n\r\n      // Create Checkout Session with embedded mode (keeps payment form in-app)\r\n      const session = await stripe.checkout.sessions.create({\r\n        customer: user.stripeCustomerId!,\r\n        mode: 'subscription',\r\n        ui_mode: 'embedded', // Enables embedded checkout\r\n        redirect_on_completion: 'always', // Force redirect after successful payment\r\n        line_items: [\r\n          {\r\n            price: priceId,\r\n            quantity: 1,\r\n          },\r\n        ],\r\n        return_url: returnUrl,\r\n        metadata: {\r\n          userId: user.id,\r\n          interval,\r\n        },\r\n      });\r\n\r\n      console.log(`[Stripe Checkout] ✓ Embedded Checkout Session created: ${session.id}`);\r\n      console.log(`[Stripe Checkout] Client secret available: ${!!session.client_secret}`);\r\n\r\n      res.json({\r\n        sessionId: session.id,\r\n        clientSecret: session.client_secret,\r\n      });\r\n    } catch (error: any) {\r\n      console.error(\"Stripe Checkout Session error:\", error);\r\n      res.status(400).json({ error: error.message });\r\n    }\r\n  });\r\n\r\n  // Stripe: Get subscription status (called after checkout redirect)\r\n  app.get('/api/subscription-status', isAuthenticated, async (req: any, res) => {\r\n    try {\r\n      const userId = (req.user as any).id || (req.user as any).claims?.sub;\r\n      const { session_id } = req.query;\r\n\r\n      const user = await storage.getUser(userId);\r\n      if (!user) {\r\n        return res.status(404).json({ error: \"User not found\" });\r\n      }\r\n\r\n      // If a session_id is provided, retrieve the session and subscription\r\n      if (session_id && typeof session_id === 'string') {\r\n        console.log(`[Stripe] Retrieving checkout session: ${session_id}`);\r\n        \r\n        const session = await stripe.checkout.sessions.retrieve(session_id, {\r\n          expand: ['subscription'],\r\n        });\r\n\r\n        if (session.payment_status === 'paid' && session.subscription) {\r\n          const subscription = session.subscription as any;\r\n          \r\n          console.log(`[Stripe] Checkout successful for user ${userId}`);\r\n          console.log(`[Stripe] Subscription ID: ${subscription.id}`);\r\n          console.log(`[Stripe] Subscription status: ${subscription.status}`);\r\n\r\n          // Update user with subscription info\r\n          await storage.updateUserStripeInfo(user.id, user.stripeCustomerId || undefined, subscription.id);\r\n          await storage.updateUserPremiumStatus(user.id, true);\r\n\r\n          return res.json({\r\n            subscriptionId: subscription.id,\r\n            status: subscription.status,\r\n            isPremium: true,\r\n          });\r\n        }\r\n      }\r\n\r\n      // Otherwise, check existing subscription status\r\n      if (user.stripeSubscriptionId) {\r\n        const subscription = await stripe.subscriptions.retrieve(user.stripeSubscriptionId);\r\n        \r\n        return res.json({\r\n          subscriptionId: subscription.id,\r\n          status: subscription.status,\r\n          isPremium: user.isPremium || false,\r\n        });\r\n      }\r\n\r\n      // No subscription found\r\n      res.json({\r\n        isPremium: user.isPremium || false,\r\n      });\r\n    } catch (error: any) {\r\n      console.error(\"Subscription status error:\", error);\r\n      res.status(400).json({ error: error.message });\r\n    }\r\n  });\r\n\r\n  // Stripe: Create customer portal session\r\n  app.post('/api/create-portal-session', isAuthenticated, async (req: any, res) => {\r\n    try {\r\n      const userId = (req.user as any).id || (req.user as any).claims?.sub;\r\n      const user = await storage.getUser(userId);\r\n\r\n      if (!user || !user.stripeCustomerId) {\r\n        return res.status(404).json({ error: \"No Stripe customer found\" });\r\n      }\r\n\r\n      const session = await stripe.billingPortal.sessions.create({\r\n        customer: user.stripeCustomerId,\r\n        return_url: `${req.protocol}://${req.get('host')}/account`,\r\n      });\r\n\r\n      res.json({ url: session.url });\r\n    } catch (error: any) {\r\n      console.error(\"Portal session error:\", error);\r\n      res.status(400).json({ error: error.message });\r\n    }\r\n  });\r\n\r\n  // Stripe: Webhook handler\r\n  app.post('/api/stripe-webhook', async (req, res) => {\r\n    const sig = req.headers['stripe-signature'];\r\n\r\n    if (!sig || !process.env.STRIPE_WEBHOOK_SECRET) {\r\n      return res.status(400).send('Webhook signature missing');\r\n    }\r\n\r\n    let event: Stripe.Event;\r\n\r\n    try {\r\n      event = stripe.webhooks.constructEvent(\r\n        req.body,\r\n        sig,\r\n        process.env.STRIPE_WEBHOOK_SECRET\r\n      );\r\n    } catch (err: any) {\r\n      console.error('Webhook signature verification failed:', err.message);\r\n      return res.status(400).send(`Webhook Error: ${err.message}`);\r\n    }\r\n\r\n    // Handle the event\r\n    try {\r\n      switch (event.type) {\r\n        case 'checkout.session.completed': {\r\n          const session = event.data.object as Stripe.Checkout.Session;\r\n          const customerId = session.customer as string;\r\n          \r\n          console.log(`[Webhook] Checkout session completed: ${session.id}`);\r\n          console.log(`[Webhook] Customer: ${customerId}`);\r\n          console.log(`[Webhook] Payment status: ${session.payment_status}`);\r\n          \r\n          if (session.payment_status === 'paid' && session.subscription) {\r\n            const subscriptionId = session.subscription as string;\r\n            const subscription = await stripe.subscriptions.retrieve(subscriptionId);\r\n            \r\n            // Find user by Stripe customer ID\r\n            const users = await storage.getAllUsers();\r\n            const user = users.find((u: User) => u.stripeCustomerId === customerId);\r\n            \r\n            if (user) {\r\n              console.log(`[Webhook] Activating premium for user: ${user.id}`);\r\n              await storage.updateUserStripeInfo(user.id, customerId, subscriptionId);\r\n              await storage.updateUserPremiumStatus(user.id, true);\r\n            } else {\r\n              console.warn(`[Webhook] User not found for customer: ${customerId}`);\r\n            }\r\n          }\r\n          break;\r\n        }\r\n\r\n        case 'customer.subscription.created':\r\n        case 'customer.subscription.updated': {\r\n          const subscription = event.data.object as Stripe.Subscription;\r\n          const customerId = subscription.customer as string;\r\n          \r\n          console.log(`[Webhook] Subscription ${event.type}: ${subscription.id}`);\r\n          console.log(`[Webhook] Status: ${subscription.status}`);\r\n          \r\n          // Find user by Stripe customer ID\r\n          const users = await storage.getAllUsers();\r\n          const user = users.find((u: User) => u.stripeCustomerId === customerId);\r\n          \r\n          if (user) {\r\n            const isActive = subscription.status === 'active' || subscription.status === 'trialing';\r\n            await storage.updateUserPremiumStatus(user.id, isActive);\r\n            await storage.updateUserStripeInfo(user.id, customerId, subscription.id);\r\n          }\r\n          break;\r\n        }\r\n\r\n        case 'customer.subscription.deleted': {\r\n          const subscription = event.data.object as Stripe.Subscription;\r\n          const customerId = subscription.customer as string;\r\n          \r\n          console.log(`[Webhook] Subscription deleted: ${subscription.id}`);\r\n          \r\n          const users = await storage.getAllUsers();\r\n          const user = users.find((u: User) => u.stripeCustomerId === customerId);\r\n          \r\n          if (user) {\r\n            await storage.updateUserPremiumStatus(user.id, false);\r\n          }\r\n          break;\r\n        }\r\n\r\n        default:\r\n          console.log(`[Webhook] Unhandled event type: ${event.type}`);\r\n      }\r\n\r\n      res.json({ received: true });\r\n    } catch (error: any) {\r\n      console.error('Webhook handler error:', error);\r\n      res.status(500).json({ error: error.message });\r\n    }\r\n  });\r\n\r\n  // ============================================\r\n  // PRONUNCIATION ASSESSMENT ROUTES\r\n  // ============================================\r\n\r\n  // POST /api/pronunciation/assess - Hybrid pronunciation assessment\r\n  app.post(\"/api/pronunciation/assess\", isAuthenticated, async (req: any, res) => {\r\n    try {\r\n      const userId = (req.user as any).id || (req.user as any).claims?.sub;\r\n      const user = await storage.getUser(userId);\r\n      if (!user) {\r\n        return res.status(404).json({ error: \"User not found\" });\r\n      }\r\n\r\n      const { \r\n        songId, \r\n        lineId, \r\n        wordIndex, \r\n        locale, \r\n        referenceText, \r\n        audioBase64,\r\n        requestAzure = false, // Explicit flag to request Azure assessment\r\n      } = req.body;\r\n\r\n      // Validate required fields\r\n      if (!songId || !locale || !referenceText || !audioBase64) {\r\n        return res.status(400).json({ \r\n          error: \"Missing required fields: songId, locale, referenceText, audioBase64\" \r\n        });\r\n      }\r\n\r\n      // Create assessment hash for caching\r\n      const crypto = await import('crypto');\r\n      const assessmentHash = crypto\r\n        .createHash('sha256')\r\n        .update(`${audioBase64}-${referenceText}-${locale}`)\r\n        .digest('hex');\r\n\r\n      // 1. CHECK CACHE FIRST (70% reduction)\r\n      const cachedAssessment = await storage.getPronunciationAssessment(assessmentHash);\r\n      if (cachedAssessment) {\r\n        console.log('[Pronunciation] Cache hit for assessment:', assessmentHash.substring(0, 8));\r\n        return res.json({\r\n          source: cachedAssessment.source,\r\n          cached: true,\r\n          assessment: {\r\n            accuracyScore: cachedAssessment.accuracyScore,\r\n            fluencyScore: cachedAssessment.fluencyScore,\r\n            completenessScore: cachedAssessment.completenessScore,\r\n            prosodyScore: cachedAssessment.prosodyScore,\r\n            pronunciationScore: cachedAssessment.pronunciationScore,\r\n            miscueMetadata: cachedAssessment.miscueMetadata ? JSON.parse(cachedAssessment.miscueMetadata) : null,\r\n          },\r\n        });\r\n      }\r\n\r\n      // 2. DECIDE: BROWSER OR AZURE? (Hybrid Model with Server-Side Enforcement)\r\n      \r\n      // Free users: ALWAYS browser\r\n      if (!user.isPremium) {\r\n        const expiresAt = new Date(Date.now() + 14 * 24 * 60 * 60 * 1000);\r\n        \r\n        await storage.savePronunciationAssessment({\r\n          userId,\r\n          songId,\r\n          lineId: lineId || null,\r\n          wordIndex: wordIndex || null,\r\n          locale,\r\n          source: 'browser',\r\n          assessmentHash,\r\n          azurePayload: null,\r\n          accuracyScore: null,\r\n          fluencyScore: null,\r\n          completenessScore: null,\r\n          prosodyScore: null,\r\n          pronunciationScore: null,\r\n          miscueMetadata: null,\r\n          expiresAt,\r\n        });\r\n\r\n        return res.json({\r\n          source: 'browser',\r\n          cached: false,\r\n          message: 'Use browser Web Speech API for instant feedback. Upgrade to premium for detailed Azure scoring.',\r\n        });\r\n      }\r\n\r\n      // Premium users: SERVER-SIDE 90/10 ENFORCEMENT\r\n      // Strategy: Probabilistic gating (race-condition free)\r\n      // - 10% of requests randomly get Azure (Math.random() < 0.10)\r\n      // - Statistically guarantees 10% Azure usage over time\r\n      // - No race conditions (no shared state to check)\r\n      // - Client cannot bypass (server-side random decision)\r\n      // This ensures costs stay at $0.075/month per user regardless of client behavior\r\n      \r\n      const billingWindowStart = new Date();\r\n      billingWindowStart.setDate(1);\r\n      billingWindowStart.setHours(0, 0, 0, 0);\r\n      \r\n      const usageStats = await storage.getUserUsageStats(userId, 'pronunciation_assessment');\r\n      const currentAzureUsage = usageStats.currentPeriodUsage;\r\n      \r\n      const TARGET_AZURE_PROBABILITY = 0.10; // 10% chance of Azure\r\n      const PREMIUM_MONTHLY_LIMIT = 10000;\r\n      \r\n      // Enforce 90/10 split with PROBABILISTIC GATING (race-condition free):\r\n      // 1. If quota exceeded → force browser\r\n      // 2. If client didn't request Azure → use browser\r\n      // 3. If client requested Azure → 10% random chance of approval\r\n      \r\n      const quotaExceeded = currentAzureUsage >= PREMIUM_MONTHLY_LIMIT;\r\n      const randomlySelected = Math.random() < TARGET_AZURE_PROBABILITY;\r\n      \r\n      // Server decides: Azure only if requested AND randomly selected AND quota ok\r\n      const shouldUseAzure = requestAzure && randomlySelected && !quotaExceeded;\r\n\r\n      if (!shouldUseAzure) {\r\n        // Force browser to maintain 90/10 ratio\r\n        const expiresAt = new Date(Date.now() + 14 * 24 * 60 * 60 * 1000);\r\n        \r\n        await storage.savePronunciationAssessment({\r\n          userId,\r\n          songId,\r\n          lineId: lineId || null,\r\n          wordIndex: wordIndex || null,\r\n          locale,\r\n          source: 'browser',\r\n          assessmentHash,\r\n          azurePayload: null,\r\n          accuracyScore: null,\r\n          fluencyScore: null,\r\n          completenessScore: null,\r\n          prosodyScore: null,\r\n          pronunciationScore: null,\r\n          miscueMetadata: null,\r\n          expiresAt,\r\n        });\r\n\r\n        const reason = quotaExceeded \r\n          ? 'Monthly Azure quota reached. Using browser scoring.'\r\n          : !requestAzure\r\n          ? 'Using browser Web Speech API for instant feedback.'\r\n          : 'Maintaining 90/10 browser/Azure ratio. Using browser scoring for cost efficiency.';\r\n\r\n        console.log(`[Pronunciation] Using browser - ${reason}`, {\r\n          userId,\r\n          requestAzure,\r\n          randomlySelected,\r\n          quotaExceeded,\r\n          currentAzureUsage,\r\n        });\r\n\r\n        return res.json({\r\n          source: 'browser',\r\n          cached: false,\r\n          message: reason,\r\n          stats: {\r\n            azureUsage: currentAzureUsage,\r\n            azureLimit: PREMIUM_MONTHLY_LIMIT,\r\n            percentUsed: Math.round((currentAzureUsage / PREMIUM_MONTHLY_LIMIT) * 100),\r\n          },\r\n        });\r\n      }\r\n\r\n      // 3. AZURE ASSESSMENT (Premium + Explicit Request + Ratio Allows)\r\n      // At this point, server has approved Azure usage based on:\r\n      // - User is premium\r\n      // - Client requested Azure\r\n      // - Quota not exceeded\r\n      // - 90/10 ratio maintained\r\n\r\n      // Optimize audio (40-60% cost savings)\r\n      const { optimizeForAzureSpeech } = await import('./audio-utils');\r\n      const optimizationResult = optimizeForAzureSpeech(audioBase64);\r\n      \r\n      console.log(`[Pronunciation] Audio optimized - compression: ${optimizationResult.compressionRatio.toFixed(1)}%`);\r\n\r\n      // Call Azure Speech Services\r\n      const { assessPronunciation } = await import('./azure-speech');\r\n      const azureResult = await assessPronunciation(\r\n        optimizationResult.audioBuffer,\r\n        {\r\n          referenceText,\r\n          granularity: 'Phoneme',\r\n          enableMiscue: true,\r\n        },\r\n        locale\r\n      );\r\n\r\n      // Record Azure usage\r\n      await storage.recordAzureUsage({\r\n        userId,\r\n        feature: 'pronunciation_assessment',\r\n        granularity: 'word',\r\n        units: 1,\r\n        billingWindowStart,\r\n      });\r\n\r\n      // Save assessment to cache (14-day expiration)\r\n      const expiresAt = new Date(Date.now() + 14 * 24 * 60 * 60 * 1000);\r\n      \r\n      // Extract miscue information from word-level error types\r\n      const miscues = azureResult.words\r\n        ?.filter(w => w.errorType && w.errorType !== 'None')\r\n        .map(w => ({\r\n          word: w.word,\r\n          errorType: w.errorType,\r\n        })) || [];\r\n      \r\n      const savedAssessment = await storage.savePronunciationAssessment({\r\n        userId,\r\n        songId,\r\n        lineId: lineId || null,\r\n        wordIndex: wordIndex || null,\r\n        locale,\r\n        source: 'azure',\r\n        assessmentHash,\r\n        azurePayload: JSON.stringify(azureResult.rawResponse),\r\n        accuracyScore: azureResult.accuracyScore,\r\n        fluencyScore: azureResult.fluencyScore,\r\n        completenessScore: azureResult.completenessScore,\r\n        prosodyScore: azureResult.prosodyScore,\r\n        pronunciationScore: azureResult.pronunciationScore,\r\n        miscueMetadata: JSON.stringify(miscues),\r\n        expiresAt,\r\n      });\r\n\r\n      console.log('[Pronunciation] Azure assessment completed:', {\r\n        userId,\r\n        songId,\r\n        hash: assessmentHash.substring(0, 8),\r\n        score: azureResult.pronunciationScore,\r\n      });\r\n\r\n      return res.json({\r\n        source: 'azure',\r\n        cached: false,\r\n        assessment: {\r\n          accuracyScore: savedAssessment.accuracyScore,\r\n          fluencyScore: savedAssessment.fluencyScore,\r\n          completenessScore: savedAssessment.completenessScore,\r\n          prosodyScore: savedAssessment.prosodyScore,\r\n          pronunciationScore: savedAssessment.pronunciationScore,\r\n          miscueMetadata: JSON.parse(savedAssessment.miscueMetadata || '[]'),\r\n          words: azureResult.words,\r\n        },\r\n      });\r\n    } catch (error: any) {\r\n      console.error('[Pronunciation] Assessment error:', error);\r\n      res.status(500).json({ error: error.message || 'Pronunciation assessment failed' });\r\n    }\r\n  });\r\n\r\n  // GET /api/pronunciation/history/:songId - Get user's pronunciation assessments for a song\r\n  app.get(\"/api/pronunciation/history/:songId\", isAuthenticated, async (req: any, res) => {\r\n    try {\r\n      const userId = (req.user as any).id || (req.user as any).claims?.sub;\r\n      const { songId } = req.params;\r\n\r\n      const assessments = await storage.getUserPronunciationAssessments(userId, songId);\r\n\r\n      return res.json({\r\n        songId,\r\n        assessments: assessments.map(a => ({\r\n          id: a.id,\r\n          lineId: a.lineId,\r\n          wordIndex: a.wordIndex,\r\n          locale: a.locale,\r\n          source: a.source,\r\n          accuracyScore: a.accuracyScore,\r\n          fluencyScore: a.fluencyScore,\r\n          completenessScore: a.completenessScore,\r\n          prosodyScore: a.prosodyScore,\r\n          pronunciationScore: a.pronunciationScore,\r\n          createdAt: a.createdAt,\r\n        })),\r\n      });\r\n    } catch (error: any) {\r\n      console.error('[Pronunciation] History fetch error:', error);\r\n      res.status(500).json({ error: error.message || 'Failed to fetch pronunciation history' });\r\n    }\r\n  });\r\n\r\n  // GET /api/pronunciation/usage - Get user's Azure usage stats\r\n  app.get(\"/api/pronunciation/usage\", isAuthenticated, async (req: any, res) => {\r\n    try {\r\n      const userId = (req.user as any).id || (req.user as any).claims?.sub;\r\n      const user = await storage.getUser(userId);\r\n\r\n      if (!user) {\r\n        return res.status(404).json({ error: \"User not found\" });\r\n      }\r\n\r\n      const usageStats = await storage.getUserUsageStats(userId, 'pronunciation_assessment');\r\n      const PREMIUM_MONTHLY_LIMIT = 10000;\r\n      const FREE_MONTHLY_LIMIT = 0; // Free users use browser only\r\n\r\n      const limit = user.isPremium ? PREMIUM_MONTHLY_LIMIT : FREE_MONTHLY_LIMIT;\r\n\r\n      return res.json({\r\n        isPremium: user.isPremium,\r\n        currentPeriodUsage: usageStats.currentPeriodUsage,\r\n        limit,\r\n        billingWindowStart: usageStats.billingWindowStart,\r\n        percentUsed: limit > 0 ? Math.round((usageStats.currentPeriodUsage / limit) * 100) : 0,\r\n      });\r\n    } catch (error: any) {\r\n      console.error('[Pronunciation] Usage stats error:', error);\r\n      res.status(500).json({ error: error.message || 'Failed to fetch usage stats' });\r\n    }\r\n  });\r\n\r\n  const httpServer = createServer(app);\r\n\r\n  return httpServer;\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../server/routes.ts b/../server/routes.ts
--- a/../server/routes.ts	(revision 9b9dda4a5767c994ce1eed3dade5009c7b928a8c)
+++ b/../server/routes.ts	(date 1763962374925)
@@ -1,285 +1,4 @@
-import type { Express } from "express";
-import { createServer, type Server } from "http";
-import { randomBytes } from "crypto";
-import Stripe from "stripe";
-import passport from "passport";
-import bcrypt from "bcryptjs";
-import { storage } from "./storage";
-import { batchTranslateLyrics, detectLanguage } from "./azure-translator";
-import { setupAuth, isAuthenticated } from "./replitAuth";
-import { getACRCloudClient } from "./acrcloud";
-import { fetchLyricsFromLrcLib } from "./lrclib";
-import { getTrackDetails } from "./spotify";
-import { searchITunes, searchITunesTracks } from "./itunes";
-import {
-  translateLyricsRequestSchema,
-  recognizeSongRequestSchema,
-  updateUserProfileSchema,
-  manualSelectSongSchema,
-  updatePracticeStatsSchema,
-  type RecognitionResult,
-  type User,
-} from "@shared/schema";
-import { ZodError, z } from "zod";
-
-if (!process.env.STRIPE_SECRET_KEY) {
-  throw new Error('Missing required Stripe secret: STRIPE_SECRET_KEY');
-}
-if (!process.env.STRIPE_PRICE_ID) {
-  throw new Error('Missing required Stripe secret: STRIPE_PRICE_ID');
-}
-const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);
-
-export async function registerRoutes(app: Express): Promise<Server> {
-  // Setup authentication - NEW MULTI-PROVIDER AUTH
-  const { setupNewAuth } = await import("./auth");
-  await setupNewAuth(app);
-
-  // New auth endpoint - get current user (updated for new auth system)
-  app.get("/api/auth/user", (req: any, res) => {
-    if (!req.user) {
-      return res.status(401).json({ error: "Not authenticated" });
-    }
-    res.json(req.user);
-  });
-
-  // OLD - Keep for backward compatibility but won't be used
-  // Auth endpoint - get current user
-  app.get("/api/auth/user-old", isAuthenticated, async (req: any, res) => {
-    try {
-      const userId = (req.user as any).id || (req.user as any).claims?.sub;
-      const user = await storage.getUser(userId);
-      res.json(user);
-    } catch (error) {
-      console.error("Error fetching user:", error);
-      res.status(500).json({ message: "Failed to fetch user" });
-    }
-  });
-
-  // Update user profile
-  app.put('/api/user/profile', isAuthenticated, async (req: any, res) => {
-    try {
-      const userId = (req.user as any).id || (req.user as any).claims?.sub;
-      const validated = updateUserProfileSchema.parse(req.body);
-      
-      const updatedUser = await storage.updateUserProfile(userId, validated);
-      
-      if (!updatedUser) {
-        return res.status(404).json({ error: "User not found" });
-      }
-      
-      res.json(updatedUser);
-    } catch (error) {
-      console.error("Error updating user profile:", error);
-      
-      if (error instanceof ZodError) {
-        return res.status(400).json({ 
-          error: "Invalid profile data",
-          details: error.errors 
-        });
-      }
-      
-      if (error instanceof Error) {
-        const pgError = error as any;
-        if (pgError.code === '23505' || error.message.includes('unique constraint')) {
-          return res.status(409).json({ error: "Username already taken" });
-        }
-      }
-      
-      res.status(500).json({ error: "Failed to update profile" });
-    }
-  });
-
-  // Reset daily translation count (for testing purposes)
-  app.post('/api/user/reset-translations', isAuthenticated, async (req: any, res) => {
-    try {
-      const userId = (req.user as any).id || (req.user as any).claims?.sub;
-      const user = await storage.getUser(userId);
-
-      if (!user) {
-        return res.status(404).json({ error: "User not found" });
-      }
-
-      // Reset the translation count to 0
-      await storage.updateUserTranslationCount(user.id, 0, new Date().toISOString());
-
-      res.json({ success: true, message: "Translation count reset successfully" });
-    } catch (error) {
-      console.error("Error resetting translations:", error);
-      res.status(500).json({ error: "Failed to reset translation count" });
-    }
-  });
-
-  // Google OAuth routes
-  // Initiate Google OAuth
-  app.get('/auth/google', passport.authenticate('google', { 
-    scope: ['profile', 'email'] 
-  }));
-
-  // Google OAuth callback
-  app.get('/api/auth/google/callback', 
-    passport.authenticate('google', { failureRedirect: '/#/auth/login' }),
-    (req: any, res) => {
-      // Redirect to home page after successful login
-      res.redirect('/#/');
-    }
-  );
-
-  // Apple OAuth routes
-  app.get('/auth/apple', passport.authenticate('apple', {
-    scope: ['name', 'email']
-  }));
-
-  app.get('/api/auth/apple/callback',
-    passport.authenticate('apple', { failureRedirect: '/#/auth/login' }),
-    (req: any, res) => {
-      res.redirect('/#/');
-    }
-  );
-
-  // Facebook OAuth routes
-  app.get('/auth/facebook', passport.authenticate('facebook', {
-    scope: ['email', 'public_profile']
-  }));
-
-  app.get('/api/auth/facebook/callback',
-    passport.authenticate('facebook', { failureRedirect: '/#/auth/login' }),
-    (req: any, res) => {
-      res.redirect('/#/');
-    }
-  );
-
-  // Twitter OAuth routes
-  app.get('/auth/twitter', passport.authenticate('twitter'));
-
-  app.get('/api/auth/twitter/callback',
-    passport.authenticate('twitter', { failureRedirect: '/#/auth/login' }),
-    (req: any, res) => {
-      res.redirect('/#/');
-    }
-  );
-
-  // Login route - password-based auth
-  app.post('/api/auth/login', async (req: any, res, next) => {
-    passport.authenticate('local', (err: any, user: any, info: any) => {
-      if (err) {
-        return res.status(500).json({ error: 'Authentication error' });
-      }
-      if (!user) {
-        return res.status(401).json({ error: info?.message || 'Invalid credentials' });
-      }
-      req.logIn(user, (err: any) => {
-        if (err) {
-          return res.status(500).json({ error: 'Login failed' });
-        }
-        res.json({ user });
-      });
-    })(req, res, next);
-  });
-
-  // Signup route
-  app.post('/api/auth/signup', async (req: any, res) => {
-    try {
-      const { email, password, username, firstName, lastName } = req.body;
-
-      if (!email || !password || !username) {
-        return res.status(400).json({ error: 'Email, password, and username are required' });
-      }
-
-      // Check if user already exists
-      const existingUser = await storage.getUserByEmail(email);
-      if (existingUser) {
-        return res.status(409).json({ error: 'Email already registered' });
-      }
-
-      // Hash password
-      const passwordHash = await bcrypt.hash(password, 10);
-
-      // Create user
-      const user = await storage.createUser({
-        id: randomBytes(16).toString('hex'),
-        email,
-        passwordHash,
-        username,
-        firstName,
-        lastName,
-        authProvider: 'password',
-        isGuest: false,
-      });
-
-      // Log in the user
-      req.logIn(user, (err: any) => {
-        if (err) {
-          return res.status(500).json({ error: 'Signup failed' });
-        }
-        res.json({ user });
-      });
-    } catch (error) {
-      console.error('Signup error:', error);
-      res.status(500).json({ error: 'Signup failed' });
-    }
-  });
-
-  // Guest mode route
-  app.post('/api/auth/guest', async (req: any, res) => {
-    try {
-      // Create a guest user
-      const guestUser = await storage.createUser({
-        id: randomBytes(16).toString('hex'),
-        email: `guest-${Date.now()}@lyricsensei.local`,
-        username: `Guest_${Math.random().toString(36).substring(7)}`,
-        authProvider: 'guest',
-        isGuest: true,
-      });
-
-      // Log in the guest user
-      req.logIn(guestUser, (err: any) => {
-        if (err) {
-          return res.status(500).json({ error: 'Guest login failed' });
-        }
-        res.json({ user: guestUser });
-      });
-    } catch (error) {
-      console.error('Guest login error:', error);
-      res.status(500).json({ error: 'Guest login failed' });
-    }
-  });
-
-  // Logout route
-  app.post('/api/auth/logout', (req: any, res) => {
-    req.logOut((err: any) => {
-      if (err) {
-        return res.status(500).json({ error: 'Logout failed' });
-      }
-      res.json({ success: true });
-    });
-  });
-
-  // Search for songs using iTunes API (MUST come before :id route)
-  app.get("/api/songs/search", async (req, res) => {
-    try {
-      const query = req.query.q as string;
-      
-      if (!query || query.trim().length === 0) {
-        return res.status(400).json({ error: "Search query is required" });
-      }
-
-      if (query.trim().length < 2) {
-        return res.status(400).json({ error: "Search query must be at least 2 characters" });
-      }
-
-      console.log('[API] Searching for tracks:', query);
-      
-      const results = await searchITunesTracks(query, 20);
-      
-      res.json({ results });
-    } catch (error) {
-      console.error("Error searching songs:", error);
-      res.status(500).json({ error: "Failed to search songs" });
-    }
-  });
-
-  // Get top researched songs (MUST come before :id route)
+ute)
   app.get("/api/songs/top-researched", async (_req, res) => {
     try {
       const topSongs = await storage.getTopResearchedSongs(10);
@@ -477,21 +196,27 @@
       }
       
       if (translations.length === 0) {
-        // Check user authentication - but allow unauthenticated access with limitations
-        let userId: string | null = null;
-        if (req.isAuthenticated()) {
+        // Check for guest user OR authenticated user
+        const guestId = req.headers['x-guest-id'];
+        let userId: string;
+
+        if (guestId && typeof guestId === 'string' && guestId.startsWith('guest-')) {
+          userId = guestId;
+        } else if (req.isAuthenticated()) {
           userId = (req.user as any).claims.sub;
-          
-          // Check daily translation limit for free users
-          const limitCheck = await storage.checkAndUpdateTranslationLimit(userId!);
-          
-          if (!limitCheck.allowed) {
-            return res.status(429).json({ 
-              error: "Daily translation limit reached. Upgrade to Premium for unlimited translations!",
-              dailyLimitReached: true,
-              remaining: 0
-            });
-          }
+        } else {
+          return res.status(401).json({ error: "Authentication required" });
+        }
+
+        // Check daily translation limit (apply to all users including guests)
+        const limitCheck = await storage.checkAndUpdateTranslationLimit(userId);
+
+        if (!limitCheck.allowed) {
+          return res.status(429).json({ 
+            error: "Daily translation limit reached. Upgrade to Premium for unlimited translations!",
+            dailyLimitReached: true,
+            remaining: 0
+          });
         }
 
         // Generate new translations (lyrics already fetched above)
@@ -575,1097 +300,4 @@
       },
       azureTranslator: {
         configured: !!(process.env.AZURE_TRANSLATOR_KEY && process.env.AZURE_TRANSLATOR_REGION),
-        keySet: !!process.env.AZURE_TRANSLATOR_KEY,
-        regionSet: !!process.env.AZURE_TRANSLATOR_REGION,
-      },
-      database: {
-        configured: !!process.env.DATABASE_URL,
-      },
-      session: {
-        configured: !!process.env.SESSION_SECRET,
-      },
-    };
-    
-    res.json(health);
-  });
-
-  // Recognize song using ACRCloud
-  app.post("/api/recognize", async (req, res) => {
-    try {
-      const validated = recognizeSongRequestSchema.parse(req.body);
-      
-      // Check user authentication
-      if (!req.isAuthenticated()) {
-        return res.status(401).json({ error: "Authentication required" });
-      }
-
-      const userId = (req.user as any).claims.sub;
-      
-      // Use ACRCloud for real song recognition
-      try {
-        const acrcloud = getACRCloudClient();
-        const recognizedSong = await acrcloud.recognizeSong(validated.audioData);
-        
-        if (!recognizedSong) {
-          return res.status(404).json({ 
-            error: "Song not recognized. Please try recording a clearer sample or a different part of the song." 
-          });
-        }
-
-        // Fetch album art and metadata from iTunes (free, no auth required)
-        let albumArtUrl = recognizedSong.albumArtUrl;
-        let actualDuration = recognizedSong.durationMs ? Math.round(recognizedSong.durationMs / 1000) : 180;
-        
-        try {
-          const itunesData = await searchITunes(
-            recognizedSong.artist,
-            recognizedSong.album,
-            recognizedSong.title
-          );
-          
-          if (itunesData) {
-            albumArtUrl = itunesData.artworkUrl;
-            console.log('[Recognition] Fetched album art from iTunes');
-            
-            if (itunesData.duration) {
-              actualDuration = itunesData.duration;
-              console.log('[Recognition] Using iTunes duration:', actualDuration, 'seconds');
-            }
-          }
-        } catch (err) {
-          console.error('[Recognition] Failed to fetch from iTunes:', err);
-        }
-        
-        // Fallback to Spotify if iTunes didn't work
-        if (!albumArtUrl && recognizedSong.spotifyTrackId) {
-          try {
-            const { albumArt } = await getTrackDetails(recognizedSong.spotifyTrackId);
-            if (albumArt) {
-              albumArtUrl = albumArt;
-              console.log('[Recognition] Fetched album art from Spotify (fallback)');
-            }
-          } catch (err) {
-            console.error('[Recognition] Failed to fetch from Spotify:', err);
-          }
-        }
-        
-        // Find or create song in database with accurate duration
-        const song = await storage.findOrCreateSongByMetadata(
-          recognizedSong.title,
-          recognizedSong.artist,
-          recognizedSong.album,
-          albumArtUrl,
-          actualDuration
-        );
-        
-        // Update song with preview offset if available
-        const updates: any = {};
-        if (recognizedSong.playOffsetMs !== undefined) {
-          updates.previewOffsetSeconds = Math.round(recognizedSong.playOffsetMs / 1000);
-          console.log('[Recognition] Updating song with preview offset:', updates.previewOffsetSeconds, 'seconds');
-        }
-        
-        if (Object.keys(updates).length > 0) {
-          await storage.updateSong(song.id, updates);
-        }
-        
-        // Fetch and save lyrics from LrcLib (don't wait for it)
-        fetchLyricsFromLrcLib(
-          recognizedSong.title,
-          recognizedSong.artist,
-          recognizedSong.album,
-          song.duration
-        ).then(async (lyricsResult) => {
-          if (lyricsResult && lyricsResult.lyrics.length > 0) {
-            console.log('[Recognition] Saving', lyricsResult.lyrics.length, 'lyrics lines for song:', song.id);
-            
-            // Convert parsed lyrics to LyricLine format
-            const lyricLines = lyricsResult.lyrics.map((lyric, index) => ({
-              id: `${song.id}-${index}`,
-              startTime: lyric.startTime,
-              endTime: lyricsResult.lyrics[index + 1]?.startTime || song.duration,
-              text: lyric.text,
-            }));
-            
-            await storage.saveLyrics(song.id, lyricLines);
-            await storage.updateSong(song.id, { hasSyncedLyrics: lyricsResult.isSynced });
-            console.log('[Recognition] Lyrics saved successfully (synced:', lyricsResult.isSynced, ')');
-            
-            // Detect language from lyrics (async, fire-and-forget)
-            if (lyricLines.length > 0) {
-              const sampleText = lyricLines.slice(0, 3).map(l => l.text).join(' ');
-              detectLanguage(sampleText)
-                .then(detectedLang => {
-                  return storage.updateSong(song.id, { detectedLanguage: detectedLang });
-                })
-                .then(() => {
-                  console.log('[Recognition] Language detection completed');
-                })
-                .catch(langError => {
-                  console.error('[Recognition] Language detection failed (background):', langError);
-                });
-            }
-          } else {
-            console.log('[Recognition] No lyrics available for this song');
-          }
-        }).catch(err => {
-          console.error('[Recognition] Error saving lyrics:', err);
-        });
-        
-        // Save to recognition history
-        await storage.addRecognitionHistory({
-          userId,
-          songId: song.id,
-          confidence: recognizedSong.confidence,
-        });
-        
-        const result: RecognitionResult = {
-          songId: song.id,
-          title: song.title,
-          artist: song.artist,
-          album: song.album ?? undefined,
-          albumArt: song.albumArt ?? undefined,
-          previewOffsetSeconds: updates.previewOffsetSeconds ?? undefined,
-          confidence: recognizedSong.confidence,
-          timestamp: Date.now(),
-        };
-
-        res.json(result);
-      } catch (acrError: any) {
-        console.error("ACRCloud recognition error:", acrError);
-        
-        // Check if it's a configuration error
-        if (acrError.message?.includes("credentials not configured")) {
-          return res.status(503).json({ 
-            error: "Song recognition service is not configured. Please contact support." 
-          });
-        }
-        
-        // Check for specific ACRCloud error codes
-        if (acrError.message?.includes("2000") || acrError.message?.includes("Invalid access")) {
-          return res.status(503).json({ 
-            error: "Invalid API credentials. Please contact support." 
-          });
-        }
-        
-        if (acrError.message?.includes("3000") || acrError.message?.includes("Limit exceeded")) {
-          return res.status(429).json({ 
-            error: "Daily recognition limit exceeded. Please try again tomorrow or upgrade to Premium." 
-          });
-        }
-        
-        if (acrError.message?.includes("3001") || acrError.message?.includes("Invalid signature")) {
-          return res.status(503).json({ 
-            error: "Authentication error. Please contact support." 
-          });
-        }
-        
-        if (acrError.message?.includes("3100")) {
-          return res.status(503).json({ 
-            error: "Music recognition service is temporarily unavailable. Please try again in a moment." 
-          });
-        }
-        
-        return res.status(500).json({ 
-          error: "Failed to recognize song. Please try again." 
-        });
-      }
-    } catch (error) {
-      console.error("Recognition endpoint error:", error);
-      res.status(400).json({ error: (error as Error).message });
-    }
-  });
-
-  // Get user recognition history
-  app.get("/api/recognition-history", async (req, res) => {
-    try {
-      if (!req.isAuthenticated()) {
-        return res.status(401).json({ error: "Authentication required" });
-      }
-
-      const userId = (req.user as any).id || (req.user as any).claims?.sub;
-      const limit = parseInt(req.query.limit as string) || 50;
-      
-      const history = await storage.getUserRecognitionHistory(userId, limit);
-      
-      // Get user favorites to mark them in history
-      const favorites = await storage.getUserFavorites(userId);
-      const favoriteSongIds = new Set(favorites.map(f => f.songId));
-      
-      // Transform to RecognitionResult format for frontend
-      const results: RecognitionResult[] = history.map(h => ({
-        songId: h.song.id,
-        title: h.song.title,
-        artist: h.song.artist,
-        album: h.song.album ?? undefined,
-        albumArt: h.song.albumArt ?? undefined,
-        previewOffsetSeconds: h.song.previewOffsetSeconds ?? undefined,
-        confidence: h.confidence,
-        timestamp: h.recognizedAt.getTime(),
-        isFavorite: favoriteSongIds.has(h.song.id),
-      }));
-      
-      res.json(results);
-    } catch (error) {
-      console.error("History fetch error:", error);
-      res.status(500).json({ error: (error as Error).message });
-    }
-  });
-
-  // Get user favorites
-  app.get("/api/favorites", isAuthenticated, async (req: any, res) => {
-    try {
-      const userId = (req.user as any).id || (req.user as any).claims?.sub;
-      const favorites = await storage.getUserFavorites(userId);
-      
-      // Transform to RecognitionResult format for frontend
-      const results: RecognitionResult[] = favorites.map(f => ({
-        songId: f.song.id,
-        title: f.song.title,
-        artist: f.song.artist,
-        album: f.song.album ?? undefined,
-        albumArt: f.song.albumArt ?? undefined,
-        previewOffsetSeconds: f.song.previewOffsetSeconds ?? undefined,
-        confidence: 1.0,
-        timestamp: f.createdAt.getTime(),
-        isFavorite: true,
-      }));
-      
-      res.json(results);
-    } catch (error) {
-      console.error("Favorites fetch error:", error);
-      res.status(500).json({ error: (error as Error).message });
-    }
-  });
-
-  // Add song to favorites
-  app.post("/api/favorites/:songId", isAuthenticated, async (req: any, res) => {
-    try {
-      const userId = (req.user as any).id || (req.user as any).claims?.sub;
-      const { songId } = req.params;
-      
-      // Check if song exists
-      const song = await storage.getSong(songId);
-      if (!song) {
-        return res.status(404).json({ error: "Song not found" });
-      }
-      
-      // Check if already favorited
-      const isAlreadyFavorite = await storage.isFavorite(userId, songId);
-      if (isAlreadyFavorite) {
-        return res.json({ message: "Already favorited" });
-      }
-      
-      await storage.addFavorite(userId, songId);
-      res.json({ message: "Song added to favorites" });
-    } catch (error) {
-      console.error("Add favorite error:", error);
-      res.status(500).json({ error: (error as Error).message });
-    }
-  });
-
-  // Remove song from favorites
-  app.delete("/api/favorites/:songId", isAuthenticated, async (req: any, res) => {
-    try {
-      const userId = (req.user as any).id || (req.user as any).claims?.sub;
-      const { songId } = req.params;
-      
-      await storage.removeFavorite(userId, songId);
-      res.json({ message: "Song removed from favorites" });
-    } catch (error) {
-      console.error("Remove favorite error:", error);
-      res.status(500).json({ error: (error as Error).message });
-    }
-  });
-
-  // Check if song is favorited
-  app.get("/api/favorites/:songId/check", isAuthenticated, async (req: any, res) => {
-    try {
-      const userId = (req.user as any).id || (req.user as any).claims?.sub;
-      const { songId } = req.params;
-      
-      const isFavorite = await storage.isFavorite(userId, songId);
-      res.json({ isFavorite });
-    } catch (error) {
-      console.error("Check favorite error:", error);
-      res.status(500).json({ error: (error as Error).message });
-    }
-  });
-
-  // Practice Stats Routes
-  
-  // Update practice stats for a song
-  app.post("/api/practice-stats", isAuthenticated, async (req: any, res) => {
-    try {
-      const userId = (req.user as any).id || (req.user as any).claims?.sub;
-      
-      // Validate request body using shared schema
-      const validationSchema = updatePracticeStatsSchema
-        .extend({
-          songId: z.string().min(1),
-        })
-        .refine(
-          (data) => data.successfulAttempts <= data.totalAttempts,
-          { message: "Successful attempts cannot exceed total attempts" }
-        );
-      
-      const validated = validationSchema.parse(req.body);
-      
-      const stats = await storage.updatePracticeStats(
-        userId,
-        validated.songId,
-        validated.totalAttempts,
-        validated.successfulAttempts
-      );
-      res.json(stats);
-    } catch (error) {
-      console.error("Update practice stats error:", error);
-      
-      if (error instanceof z.ZodError) {
-        return res.status(400).json({ 
-          error: "Invalid request body",
-          details: error.errors 
-        });
-      }
-      
-      res.status(500).json({ error: (error as Error).message });
-    }
-  });
-
-  // Get all practice stats for current user
-  app.get("/api/practice-stats", isAuthenticated, async (req: any, res) => {
-    try {
-      const userId = (req.user as any).id || (req.user as any).claims?.sub;
-      const stats = await storage.getUserPracticeStats(userId);
-      res.json(stats);
-    } catch (error) {
-      console.error("Get practice stats error:", error);
-      res.status(500).json({ error: (error as Error).message });
-    }
-  });
-
-  // Get practice stats for a specific song
-  app.get("/api/practice-stats/:songId", isAuthenticated, async (req: any, res) => {
-    try {
-      const userId = (req.user as any).id || (req.user as any).claims?.sub;
-      const { songId } = req.params;
-      
-      const stats = await storage.getSongPracticeStats(userId, songId);
-      res.json(stats || null);
-    } catch (error) {
-      console.error("Get song practice stats error:", error);
-      res.status(500).json({ error: (error as Error).message });
-    }
-  });
-
-  // Social media sharing endpoint - serves Open Graph meta tags
-  app.get("/share/:songId", async (req, res) => {
-    try {
-      const { songId } = req.params;
-      const song = await storage.getSong(songId);
-      
-      if (!song) {
-        return res.redirect('/');
-      }
-      
-      const title = `${song.title} by ${song.artist} - LyricSync`;
-      const description = `Translate and learn the pronunciation of "${song.title}" in any language with LyricSync's AI-powered phonetic guides.`;
-      const imageUrl = song.albumArt || 'https://lyricsync.repl.co/icon-512.png';
-      
-      // Serve HTML with Open Graph meta tags for social crawlers
-      res.send(`
-        <!DOCTYPE html>
-        <html>
-          <head>
-            <meta charset="UTF-8" />
-            <title>${title}</title>
-            <meta name="description" content="${description}" />
-            
-            <!-- Open Graph / Facebook -->
-            <meta property="og:type" content="music.song" />
-            <meta property="og:url" content="${req.protocol}://${req.get('host')}/share/${songId}" />
-            <meta property="og:title" content="${title}" />
-            <meta property="og:description" content="${description}" />
-            <meta property="og:image" content="${imageUrl}" />
-            <meta property="og:image:width" content="1200" />
-            <meta property="og:image:height" content="630" />
-            <meta property="og:site_name" content="LyricSync" />
-            
-            <!-- Twitter -->
-            <meta property="twitter:card" content="summary_large_image" />
-            <meta property="twitter:url" content="${req.protocol}://${req.get('host')}/share/${songId}" />
-            <meta property="twitter:title" content="${title}" />
-            <meta property="twitter:description" content="${description}" />
-            <meta property="twitter:image" content="${imageUrl}" />
-            
-            <!-- Redirect for normal navigation -->
-            <meta http-equiv="refresh" content="0; url=/" />
-            <script>
-              window.location.href = '/';
-            </script>
-          </head>
-          <body>
-            <p>Redirecting to LyricSync...</p>
-          </body>
-        </html>
-      `);
-    } catch (error) {
-      console.error("Share route error:", error);
-      res.redirect('/');
-    }
-  });
-
-  // Stripe: Diagnostic endpoint to check price configuration
-  app.get('/api/stripe-price-check', isAuthenticated, async (req: any, res) => {
-    try {
-      const monthlyPriceId = process.env.STRIPE_PRICE_ID;
-      const yearlyPriceId = process.env.STRIPE_YEARLY_PRICE_ID;
-
-      const diagnostics: any = {
-        envVarsConfigured: {
-          monthly: !!monthlyPriceId,
-          yearly: !!yearlyPriceId,
-        },
-        prices: {},
-      };
-
-      if (monthlyPriceId) {
-        try {
-          const monthlyPrice = await stripe.prices.retrieve(monthlyPriceId, {
-            expand: ['product'],
-          });
-          const productData = monthlyPrice.product as any;
-          diagnostics.prices.monthly = {
-            id: monthlyPrice.id,
-            active: monthlyPrice.active,
-            type: monthlyPrice.type,
-            amount: monthlyPrice.unit_amount,
-            currency: monthlyPrice.currency,
-            recurring: monthlyPrice.recurring,
-            product: {
-              id: productData.id,
-              name: productData.name,
-              active: productData.active,
-              default_price: productData.default_price,
-            },
-          };
-        } catch (error: any) {
-          diagnostics.prices.monthly = { error: error.message };
-        }
-      }
-
-      if (yearlyPriceId) {
-        try {
-          const yearlyPrice = await stripe.prices.retrieve(yearlyPriceId, {
-            expand: ['product'],
-          });
-          const productData = yearlyPrice.product as any;
-          diagnostics.prices.yearly = {
-            id: yearlyPrice.id,
-            active: yearlyPrice.active,
-            type: yearlyPrice.type,
-            amount: yearlyPrice.unit_amount,
-            currency: yearlyPrice.currency,
-            recurring: yearlyPrice.recurring,
-            product: {
-              id: productData.id,
-              name: productData.name,
-              active: productData.active,
-              default_price: productData.default_price,
-            },
-          };
-        } catch (error: any) {
-          diagnostics.prices.yearly = { error: error.message };
-        }
-      }
-
-      res.json(diagnostics);
-    } catch (error: any) {
-      console.error("Price check error:", error);
-      res.status(500).json({ error: error.message });
-    }
-  });
-
-  // Stripe: Create Checkout Session for subscription (Stripe-recommended approach)
-  app.post('/api/create-subscription', isAuthenticated, async (req: any, res) => {
-    try {
-      const userId = (req.user as any).id || (req.user as any).claims?.sub;
-      let user = await storage.getUser(userId);
-
-      if (!user) {
-        return res.status(404).json({ error: "User not found" });
-      }
-
-      // If user already has an active subscription, redirect to account page
-      if (user.stripeSubscriptionId) {
-        const subscription = await stripe.subscriptions.retrieve(user.stripeSubscriptionId);
-        
-        if (subscription.status === 'active' || subscription.status === 'trialing') {
-          return res.json({
-            subscriptionId: subscription.id,
-            status: subscription.status,
-            alreadySubscribed: true,
-          });
-        }
-      }
-
-      // Create a new customer if needed
-      if (!user.stripeCustomerId) {
-        const customer = await stripe.customers.create({
-          email: user.email ?? undefined,
-          name: `${user.firstName || ''} ${user.lastName || ''}`.trim() || undefined,
-          metadata: {
-            userId: user.id,
-          },
-        });
-
-        await storage.updateUserStripeInfo(user.id, customer.id);
-        user = await storage.getUser(userId);
-        if (!user) {
-          return res.status(500).json({ error: "Failed to update user" });
-        }
-      }
-
-      // Determine which price to use based on interval
-      const { interval = 'month' } = req.body; // 'month' or 'year'
-      const priceId = interval === 'year' 
-        ? (process.env.STRIPE_YEARLY_PRICE_ID || process.env.STRIPE_PRICE_ID) 
-        : process.env.STRIPE_PRICE_ID;
-
-      console.log(`[Stripe Checkout] Creating Checkout Session for user ${user.id}`);
-      console.log(`[Stripe Checkout] Interval: ${interval}`);
-      console.log(`[Stripe Checkout] Price ID: ${priceId ? priceId.substring(0, 15) + '...' : 'MISSING'}`);
-
-      if (!priceId) {
-        throw new Error("Stripe price ID is not configured. Please set STRIPE_PRICE_ID and STRIPE_YEARLY_PRICE_ID in environment variables.");
-      }
-
-      // Build return URL for embedded checkout (preserve interval in query params)
-      const baseUrl = `${req.protocol}://${req.get('host')}`;
-      const returnUrl = `${baseUrl}/checkout/return?session_id={CHECKOUT_SESSION_ID}&interval=${interval}`;
-
-      // Create Checkout Session with embedded mode (keeps payment form in-app)
-      const session = await stripe.checkout.sessions.create({
-        customer: user.stripeCustomerId!,
-        mode: 'subscription',
-        ui_mode: 'embedded', // Enables embedded checkout
-        redirect_on_completion: 'always', // Force redirect after successful payment
-        line_items: [
-          {
-            price: priceId,
-            quantity: 1,
-          },
-        ],
-        return_url: returnUrl,
-        metadata: {
-          userId: user.id,
-          interval,
-        },
-      });
-
-      console.log(`[Stripe Checkout] ✓ Embedded Checkout Session created: ${session.id}`);
-      console.log(`[Stripe Checkout] Client secret available: ${!!session.client_secret}`);
-
-      res.json({
-        sessionId: session.id,
-        clientSecret: session.client_secret,
-      });
-    } catch (error: any) {
-      console.error("Stripe Checkout Session error:", error);
-      res.status(400).json({ error: error.message });
-    }
-  });
-
-  // Stripe: Get subscription status (called after checkout redirect)
-  app.get('/api/subscription-status', isAuthenticated, async (req: any, res) => {
-    try {
-      const userId = (req.user as any).id || (req.user as any).claims?.sub;
-      const { session_id } = req.query;
-
-      const user = await storage.getUser(userId);
-      if (!user) {
-        return res.status(404).json({ error: "User not found" });
-      }
-
-      // If a session_id is provided, retrieve the session and subscription
-      if (session_id && typeof session_id === 'string') {
-        console.log(`[Stripe] Retrieving checkout session: ${session_id}`);
-        
-        const session = await stripe.checkout.sessions.retrieve(session_id, {
-          expand: ['subscription'],
-        });
-
-        if (session.payment_status === 'paid' && session.subscription) {
-          const subscription = session.subscription as any;
-          
-          console.log(`[Stripe] Checkout successful for user ${userId}`);
-          console.log(`[Stripe] Subscription ID: ${subscription.id}`);
-          console.log(`[Stripe] Subscription status: ${subscription.status}`);
-
-          // Update user with subscription info
-          await storage.updateUserStripeInfo(user.id, user.stripeCustomerId || undefined, subscription.id);
-          await storage.updateUserPremiumStatus(user.id, true);
-
-          return res.json({
-            subscriptionId: subscription.id,
-            status: subscription.status,
-            isPremium: true,
-          });
-        }
-      }
-
-      // Otherwise, check existing subscription status
-      if (user.stripeSubscriptionId) {
-        const subscription = await stripe.subscriptions.retrieve(user.stripeSubscriptionId);
-        
-        return res.json({
-          subscriptionId: subscription.id,
-          status: subscription.status,
-          isPremium: user.isPremium || false,
-        });
-      }
-
-      // No subscription found
-      res.json({
-        isPremium: user.isPremium || false,
-      });
-    } catch (error: any) {
-      console.error("Subscription status error:", error);
-      res.status(400).json({ error: error.message });
-    }
-  });
-
-  // Stripe: Create customer portal session
-  app.post('/api/create-portal-session', isAuthenticated, async (req: any, res) => {
-    try {
-      const userId = (req.user as any).id || (req.user as any).claims?.sub;
-      const user = await storage.getUser(userId);
-
-      if (!user || !user.stripeCustomerId) {
-        return res.status(404).json({ error: "No Stripe customer found" });
-      }
-
-      const session = await stripe.billingPortal.sessions.create({
-        customer: user.stripeCustomerId,
-        return_url: `${req.protocol}://${req.get('host')}/account`,
-      });
-
-      res.json({ url: session.url });
-    } catch (error: any) {
-      console.error("Portal session error:", error);
-      res.status(400).json({ error: error.message });
-    }
-  });
-
-  // Stripe: Webhook handler
-  app.post('/api/stripe-webhook', async (req, res) => {
-    const sig = req.headers['stripe-signature'];
-
-    if (!sig || !process.env.STRIPE_WEBHOOK_SECRET) {
-      return res.status(400).send('Webhook signature missing');
-    }
-
-    let event: Stripe.Event;
-
-    try {
-      event = stripe.webhooks.constructEvent(
-        req.body,
-        sig,
-        process.env.STRIPE_WEBHOOK_SECRET
-      );
-    } catch (err: any) {
-      console.error('Webhook signature verification failed:', err.message);
-      return res.status(400).send(`Webhook Error: ${err.message}`);
-    }
-
-    // Handle the event
-    try {
-      switch (event.type) {
-        case 'checkout.session.completed': {
-          const session = event.data.object as Stripe.Checkout.Session;
-          const customerId = session.customer as string;
-          
-          console.log(`[Webhook] Checkout session completed: ${session.id}`);
-          console.log(`[Webhook] Customer: ${customerId}`);
-          console.log(`[Webhook] Payment status: ${session.payment_status}`);
-          
-          if (session.payment_status === 'paid' && session.subscription) {
-            const subscriptionId = session.subscription as string;
-            const subscription = await stripe.subscriptions.retrieve(subscriptionId);
-            
-            // Find user by Stripe customer ID
-            const users = await storage.getAllUsers();
-            const user = users.find((u: User) => u.stripeCustomerId === customerId);
-            
-            if (user) {
-              console.log(`[Webhook] Activating premium for user: ${user.id}`);
-              await storage.updateUserStripeInfo(user.id, customerId, subscriptionId);
-              await storage.updateUserPremiumStatus(user.id, true);
-            } else {
-              console.warn(`[Webhook] User not found for customer: ${customerId}`);
-            }
-          }
-          break;
-        }
-
-        case 'customer.subscription.created':
-        case 'customer.subscription.updated': {
-          const subscription = event.data.object as Stripe.Subscription;
-          const customerId = subscription.customer as string;
-          
-          console.log(`[Webhook] Subscription ${event.type}: ${subscription.id}`);
-          console.log(`[Webhook] Status: ${subscription.status}`);
-          
-          // Find user by Stripe customer ID
-          const users = await storage.getAllUsers();
-          const user = users.find((u: User) => u.stripeCustomerId === customerId);
-          
-          if (user) {
-            const isActive = subscription.status === 'active' || subscription.status === 'trialing';
-            await storage.updateUserPremiumStatus(user.id, isActive);
-            await storage.updateUserStripeInfo(user.id, customerId, subscription.id);
-          }
-          break;
-        }
-
-        case 'customer.subscription.deleted': {
-          const subscription = event.data.object as Stripe.Subscription;
-          const customerId = subscription.customer as string;
-          
-          console.log(`[Webhook] Subscription deleted: ${subscription.id}`);
-          
-          const users = await storage.getAllUsers();
-          const user = users.find((u: User) => u.stripeCustomerId === customerId);
-          
-          if (user) {
-            await storage.updateUserPremiumStatus(user.id, false);
-          }
-          break;
-        }
-
-        default:
-          console.log(`[Webhook] Unhandled event type: ${event.type}`);
-      }
-
-      res.json({ received: true });
-    } catch (error: any) {
-      console.error('Webhook handler error:', error);
-      res.status(500).json({ error: error.message });
-    }
-  });
-
-  // ============================================
-  // PRONUNCIATION ASSESSMENT ROUTES
-  // ============================================
-
-  // POST /api/pronunciation/assess - Hybrid pronunciation assessment
-  app.post("/api/pronunciation/assess", isAuthenticated, async (req: any, res) => {
-    try {
-      const userId = (req.user as any).id || (req.user as any).claims?.sub;
-      const user = await storage.getUser(userId);
-      if (!user) {
-        return res.status(404).json({ error: "User not found" });
-      }
-
-      const { 
-        songId, 
-        lineId, 
-        wordIndex, 
-        locale, 
-        referenceText, 
-        audioBase64,
-        requestAzure = false, // Explicit flag to request Azure assessment
-      } = req.body;
-
-      // Validate required fields
-      if (!songId || !locale || !referenceText || !audioBase64) {
-        return res.status(400).json({ 
-          error: "Missing required fields: songId, locale, referenceText, audioBase64" 
-        });
-      }
-
-      // Create assessment hash for caching
-      const crypto = await import('crypto');
-      const assessmentHash = crypto
-        .createHash('sha256')
-        .update(`${audioBase64}-${referenceText}-${locale}`)
-        .digest('hex');
-
-      // 1. CHECK CACHE FIRST (70% reduction)
-      const cachedAssessment = await storage.getPronunciationAssessment(assessmentHash);
-      if (cachedAssessment) {
-        console.log('[Pronunciation] Cache hit for assessment:', assessmentHash.substring(0, 8));
-        return res.json({
-          source: cachedAssessment.source,
-          cached: true,
-          assessment: {
-            accuracyScore: cachedAssessment.accuracyScore,
-            fluencyScore: cachedAssessment.fluencyScore,
-            completenessScore: cachedAssessment.completenessScore,
-            prosodyScore: cachedAssessment.prosodyScore,
-            pronunciationScore: cachedAssessment.pronunciationScore,
-            miscueMetadata: cachedAssessment.miscueMetadata ? JSON.parse(cachedAssessment.miscueMetadata) : null,
-          },
-        });
-      }
-
-      // 2. DECIDE: BROWSER OR AZURE? (Hybrid Model with Server-Side Enforcement)
-      
-      // Free users: ALWAYS browser
-      if (!user.isPremium) {
-        const expiresAt = new Date(Date.now() + 14 * 24 * 60 * 60 * 1000);
-        
-        await storage.savePronunciationAssessment({
-          userId,
-          songId,
-          lineId: lineId || null,
-          wordIndex: wordIndex || null,
-          locale,
-          source: 'browser',
-          assessmentHash,
-          azurePayload: null,
-          accuracyScore: null,
-          fluencyScore: null,
-          completenessScore: null,
-          prosodyScore: null,
-          pronunciationScore: null,
-          miscueMetadata: null,
-          expiresAt,
-        });
-
-        return res.json({
-          source: 'browser',
-          cached: false,
-          message: 'Use browser Web Speech API for instant feedback. Upgrade to premium for detailed Azure scoring.',
-        });
-      }
-
-      // Premium users: SERVER-SIDE 90/10 ENFORCEMENT
-      // Strategy: Probabilistic gating (race-condition free)
-      // - 10% of requests randomly get Azure (Math.random() < 0.10)
-      // - Statistically guarantees 10% Azure usage over time
-      // - No race conditions (no shared state to check)
-      // - Client cannot bypass (server-side random decision)
-      // This ensures costs stay at $0.075/month per user regardless of client behavior
-      
-      const billingWindowStart = new Date();
-      billingWindowStart.setDate(1);
-      billingWindowStart.setHours(0, 0, 0, 0);
-      
-      const usageStats = await storage.getUserUsageStats(userId, 'pronunciation_assessment');
-      const currentAzureUsage = usageStats.currentPeriodUsage;
-      
-      const TARGET_AZURE_PROBABILITY = 0.10; // 10% chance of Azure
-      const PREMIUM_MONTHLY_LIMIT = 10000;
-      
-      // Enforce 90/10 split with PROBABILISTIC GATING (race-condition free):
-      // 1. If quota exceeded → force browser
-      // 2. If client didn't request Azure → use browser
-      // 3. If client requested Azure → 10% random chance of approval
-      
-      const quotaExceeded = currentAzureUsage >= PREMIUM_MONTHLY_LIMIT;
-      const randomlySelected = Math.random() < TARGET_AZURE_PROBABILITY;
-      
-      // Server decides: Azure only if requested AND randomly selected AND quota ok
-      const shouldUseAzure = requestAzure && randomlySelected && !quotaExceeded;
-
-      if (!shouldUseAzure) {
-        // Force browser to maintain 90/10 ratio
-        const expiresAt = new Date(Date.now() + 14 * 24 * 60 * 60 * 1000);
-        
-        await storage.savePronunciationAssessment({
-          userId,
-          songId,
-          lineId: lineId || null,
-          wordIndex: wordIndex || null,
-          locale,
-          source: 'browser',
-          assessmentHash,
-          azurePayload: null,
-          accuracyScore: null,
-          fluencyScore: null,
-          completenessScore: null,
-          prosodyScore: null,
-          pronunciationScore: null,
-          miscueMetadata: null,
-          expiresAt,
-        });
-
-        const reason = quotaExceeded 
-          ? 'Monthly Azure quota reached. Using browser scoring.'
-          : !requestAzure
-          ? 'Using browser Web Speech API for instant feedback.'
-          : 'Maintaining 90/10 browser/Azure ratio. Using browser scoring for cost efficiency.';
-
-        console.log(`[Pronunciation] Using browser - ${reason}`, {
-          userId,
-          requestAzure,
-          randomlySelected,
-          quotaExceeded,
-          currentAzureUsage,
-        });
-
-        return res.json({
-          source: 'browser',
-          cached: false,
-          message: reason,
-          stats: {
-            azureUsage: currentAzureUsage,
-            azureLimit: PREMIUM_MONTHLY_LIMIT,
-            percentUsed: Math.round((currentAzureUsage / PREMIUM_MONTHLY_LIMIT) * 100),
-          },
-        });
-      }
-
-      // 3. AZURE ASSESSMENT (Premium + Explicit Request + Ratio Allows)
-      // At this point, server has approved Azure usage based on:
-      // - User is premium
-      // - Client requested Azure
-      // - Quota not exceeded
-      // - 90/10 ratio maintained
-
-      // Optimize audio (40-60% cost savings)
-      const { optimizeForAzureSpeech } = await import('./audio-utils');
-      const optimizationResult = optimizeForAzureSpeech(audioBase64);
-      
-      console.log(`[Pronunciation] Audio optimized - compression: ${optimizationResult.compressionRatio.toFixed(1)}%`);
-
-      // Call Azure Speech Services
-      const { assessPronunciation } = await import('./azure-speech');
-      const azureResult = await assessPronunciation(
-        optimizationResult.audioBuffer,
-        {
-          referenceText,
-          granularity: 'Phoneme',
-          enableMiscue: true,
-        },
-        locale
-      );
-
-      // Record Azure usage
-      await storage.recordAzureUsage({
-        userId,
-        feature: 'pronunciation_assessment',
-        granularity: 'word',
-        units: 1,
-        billingWindowStart,
-      });
-
-      // Save assessment to cache (14-day expiration)
-      const expiresAt = new Date(Date.now() + 14 * 24 * 60 * 60 * 1000);
-      
-      // Extract miscue information from word-level error types
-      const miscues = azureResult.words
-        ?.filter(w => w.errorType && w.errorType !== 'None')
-        .map(w => ({
-          word: w.word,
-          errorType: w.errorType,
-        })) || [];
-      
-      const savedAssessment = await storage.savePronunciationAssessment({
-        userId,
-        songId,
-        lineId: lineId || null,
-        wordIndex: wordIndex || null,
-        locale,
-        source: 'azure',
-        assessmentHash,
-        azurePayload: JSON.stringify(azureResult.rawResponse),
-        accuracyScore: azureResult.accuracyScore,
-        fluencyScore: azureResult.fluencyScore,
-        completenessScore: azureResult.completenessScore,
-        prosodyScore: azureResult.prosodyScore,
-        pronunciationScore: azureResult.pronunciationScore,
-        miscueMetadata: JSON.stringify(miscues),
-        expiresAt,
-      });
-
-      console.log('[Pronunciation] Azure assessment completed:', {
-        userId,
-        songId,
-        hash: assessmentHash.substring(0, 8),
-        score: azureResult.pronunciationScore,
-      });
-
-      return res.json({
-        source: 'azure',
-        cached: false,
-        assessment: {
-          accuracyScore: savedAssessment.accuracyScore,
-          fluencyScore: savedAssessment.fluencyScore,
-          completenessScore: savedAssessment.completenessScore,
-          prosodyScore: savedAssessment.prosodyScore,
-          pronunciationScore: savedAssessment.pronunciationScore,
-          miscueMetadata: JSON.parse(savedAssessment.miscueMetadata || '[]'),
-          words: azureResult.words,
-        },
-      });
-    } catch (error: any) {
-      console.error('[Pronunciation] Assessment error:', error);
-      res.status(500).json({ error: error.message || 'Pronunciation assessment failed' });
-    }
-  });
-
-  // GET /api/pronunciation/history/:songId - Get user's pronunciation assessments for a song
-  app.get("/api/pronunciation/history/:songId", isAuthenticated, async (req: any, res) => {
-    try {
-      const userId = (req.user as any).id || (req.user as any).claims?.sub;
-      const { songId } = req.params;
-
-      const assessments = await storage.getUserPronunciationAssessments(userId, songId);
-
-      return res.json({
-        songId,
-        assessments: assessments.map(a => ({
-          id: a.id,
-          lineId: a.lineId,
-          wordIndex: a.wordIndex,
-          locale: a.locale,
-          source: a.source,
-          accuracyScore: a.accuracyScore,
-          fluencyScore: a.fluencyScore,
-          completenessScore: a.completenessScore,
-          prosodyScore: a.prosodyScore,
-          pronunciationScore: a.pronunciationScore,
-          createdAt: a.createdAt,
-        })),
-      });
-    } catch (error: any) {
-      console.error('[Pronunciation] History fetch error:', error);
-      res.status(500).json({ error: error.message || 'Failed to fetch pronunciation history' });
-    }
-  });
-
-  // GET /api/pronunciation/usage - Get user's Azure usage stats
-  app.get("/api/pronunciation/usage", isAuthenticated, async (req: any, res) => {
-    try {
-      const userId = (req.user as any).id || (req.user as any).claims?.sub;
-      const user = await storage.getUser(userId);
-
-      if (!user) {
-        return res.status(404).json({ error: "User not found" });
-      }
-
-      const usageStats = await storage.getUserUsageStats(userId, 'pronunciation_assessment');
-      const PREMIUM_MONTHLY_LIMIT = 10000;
-      const FREE_MONTHLY_LIMIT = 0; // Free users use browser only
-
-      const limit = user.isPremium ? PREMIUM_MONTHLY_LIMIT : FREE_MONTHLY_LIMIT;
-
-      return res.json({
-        isPremium: user.isPremium,
-        currentPeriodUsage: usageStats.currentPeriodUsage,
-        limit,
-        billingWindowStart: usageStats.billingWindowStart,
-        percentUsed: limit > 0 ? Math.round((usageStats.currentPeriodUsage / limit) * 100) : 0,
-      });
-    } catch (error: any) {
-      console.error('[Pronunciation] Usage stats error:', error);
-      res.status(500).json({ error: error.message || 'Failed to fetch usage stats' });
-    }
-  });
-
-  const httpServer = createServer(app);
-
-  return httpServer;
-}
+    
\ No newline at end of file
Index: ../keystore-download.sh
===================================================================
diff --git a/../keystore-download.sh b/../keystore-download.sh
deleted file mode 100644
--- a/../keystore-download.sh	(revision 9b9dda4a5767c994ce1eed3dade5009c7b928a8c)
+++ /dev/null	(revision 9b9dda4a5767c994ce1eed3dade5009c7b928a8c)
@@ -1,6 +0,0 @@
-#!/bin/bash
-# Simple download server
-cd /home/runner/workspace
-python3 -m http.server 8888 --directory . > /dev/null 2>&1 &
-echo "✅ Download server started on port 8888"
-echo "📥 Download link: http://localhost:8888/lyric-sensei.keystore"
