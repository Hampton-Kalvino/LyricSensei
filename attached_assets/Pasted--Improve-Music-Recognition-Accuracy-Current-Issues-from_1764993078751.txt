# ðŸŽµ Improve Music Recognition Accuracy

## Current Issues from Logs

```
[API Response] 500
[API Error] POST https://lyricsensei.com/api/recognize: Error: 500: 
{"error":"Failed to recognize song. Please try again."}
```

The recognition is failing on the backend. Here's how to improve it:

---

## âœ… Solution 1: Increase Recording Quality & Duration

### Increase Recording Time

```typescript
// client/src/lib/recognition.ts

export async function recognizeSong() {
  // Change from 5 seconds to 10-15 seconds
  const RECORDING_DURATION = 12; // seconds (was 5)
  
  console.log(`[Recognition] Recording ${RECORDING_DURATION} seconds of audio`);
  
  // Record longer audio sample
  const audioBlob = await recordAudio(RECORDING_DURATION);
  
  // Rest of code...
}
```

**Why:** Longer audio samples give more data for fingerprinting, especially for songs with slow intros or quiet sections.

### Improve Audio Quality

```typescript
// client/src/lib/audio-recorder.ts

export async function recordAudio(duration: number): Promise<Blob> {
  const stream = await navigator.mediaDevices.getUserMedia({
    audio: {
      echoCancellation: false,      // Don't cancel music
      noiseSuppression: false,       // Don't suppress the song
      autoGainControl: false,        // Don't adjust volume
      sampleRate: 48000,             // High quality (was probably 44100)
      channelCount: 2,               // Stereo
    }
  });

  const mediaRecorder = new MediaRecorder(stream, {
    mimeType: 'audio/webm;codecs=opus',
    audioBitsPerSecond: 128000  // Higher bitrate
  });

  // Rest of recording code...
}
```

---

## âœ… Solution 2: Try Multiple Recognition Services

Use fallback services if one fails:

```typescript
// server/lib/music-recognition.ts

import axios from 'axios';

// Service 1: AudD (Primary)
async function recognizeWithAudD(audioBuffer: Buffer): Promise<RecognitionResult> {
  try {
    const formData = new FormData();
    formData.append('audio', audioBuffer, { filename: 'audio.wav' });
    formData.append('api_token', process.env.AUDD_API_KEY);
    formData.append('return', 'spotify,lyrics');

    const response = await axios.post('https://api.audd.io/', formData, {
      headers: formData.getHeaders(),
      timeout: 15000
    });

    if (response.data.result) {
      return {
        title: response.data.result.title,
        artist: response.data.result.artist,
        album: response.data.result.album,
        spotifyId: response.data.result.spotify?.id
      };
    }

    throw new Error('No match found');
  } catch (error) {
    console.error('[AudD] Recognition failed:', error);
    throw error;
  }
}

// Service 2: ACRCloud (Fallback)
async function recognizeWithACRCloud(audioBuffer: Buffer): Promise<RecognitionResult> {
  try {
    const crypto = require('crypto');
    const timestamp = Date.now();
    
    // ACRCloud signature
    const stringToSign = [
      'POST',
      '/v1/identify',
      process.env.ACRCLOUD_ACCESS_KEY,
      'audio',
      '1',
      timestamp.toString()
    ].join('\n');

    const signature = crypto
      .createHmac('sha1', process.env.ACRCLOUD_ACCESS_SECRET)
      .update(Buffer.from(stringToSign, 'utf-8'))
      .digest('base64');

    const formData = new FormData();
    formData.append('sample', audioBuffer, { filename: 'sample.wav' });
    formData.append('access_key', process.env.ACRCLOUD_ACCESS_KEY);
    formData.append('data_type', 'audio');
    formData.append('signature_version', '1');
    formData.append('signature', signature);
    formData.append('sample_bytes', audioBuffer.length.toString());
    formData.append('timestamp', timestamp.toString());

    const response = await axios.post(
      `https://${process.env.ACRCLOUD_HOST}/v1/identify`,
      formData,
      {
        headers: formData.getHeaders(),
        timeout: 15000
      }
    );

    if (response.data.status.code === 0 && response.data.metadata.music.length > 0) {
      const result = response.data.metadata.music[0];
      return {
        title: result.title,
        artist: result.artists[0].name,
        album: result.album.name,
        spotifyId: result.external_metadata?.spotify?.track?.id
      };
    }

    throw new Error('No match found');
  } catch (error) {
    console.error('[ACRCloud] Recognition failed:', error);
    throw error;
  }
}

// Service 3: Shazam API (Third option)
async function recognizeWithShazam(audioBuffer: Buffer): Promise<RecognitionResult> {
  try {
    const response = await axios.post(
      'https://shazam.p.rapidapi.com/songs/v2/detect',
      audioBuffer,
      {
        headers: {
          'content-type': 'audio/wav',
          'X-RapidAPI-Key': process.env.RAPIDAPI_KEY,
          'X-RapidAPI-Host': 'shazam.p.rapidapi.com'
        },
        params: {
          locale: 'en-US'
        },
        timeout: 15000
      }
    );

    if (response.data.track) {
      return {
        title: response.data.track.title,
        artist: response.data.track.subtitle,
        album: response.data.track.sections?.[0]?.metadata?.[0]?.text,
        spotifyId: null // Shazam doesn't provide Spotify ID
      };
    }

    throw new Error('No match found');
  } catch (error) {
    console.error('[Shazam] Recognition failed:', error);
    throw error;
  }
}

// Main recognition function with fallbacks
export async function recognizeSong(audioBuffer: Buffer): Promise<RecognitionResult> {
  const services = [
    { name: 'AudD', fn: recognizeWithAudD },
    { name: 'ACRCloud', fn: recognizeWithACRCloud },
    { name: 'Shazam', fn: recognizeWithShazam }
  ];

  for (const service of services) {
    try {
      console.log(`[Recognition] Trying ${service.name}...`);
      const result = await service.fn(audioBuffer);
      console.log(`[Recognition] Success with ${service.name}:`, result);
      return result;
    } catch (error) {
      console.error(`[Recognition] ${service.name} failed:`, error.message);
      // Continue to next service
    }
  }

  throw new Error('All recognition services failed');
}
```

---

## âœ… Solution 3: Better Error Handling & Retries

```typescript
// server/routes.ts

app.post('/api/recognize', async (req, res) => {
  try {
    const { audio } = req.body;

    if (!audio) {
      return res.status(400).json({ error: 'No audio data provided' });
    }

    // Convert base64 to buffer
    const audioBuffer = Buffer.from(audio, 'base64');

    console.log('[Recognition] Audio received:', {
      size: audioBuffer.length,
      format: 'WAV',
      sampleRate: 48000
    });

    // Validate audio size
    if (audioBuffer.length < 50000) {
      return res.status(400).json({ 
        error: 'Audio sample too short. Please record at least 5 seconds.' 
      });
    }

    // Try recognition with retries
    let result;
    let attempts = 0;
    const maxAttempts = 3;

    while (attempts < maxAttempts) {
      try {
        attempts++;
        console.log(`[Recognition] Attempt ${attempts}/${maxAttempts}`);
        
        result = await recognizeSong(audioBuffer);
        break; // Success!
        
      } catch (error) {
        console.error(`[Recognition] Attempt ${attempts} failed:`, error.message);
        
        if (attempts === maxAttempts) {
          throw error; // All attempts failed
        }
        
        // Wait before retry
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    if (!result) {
      return res.status(404).json({ 
        error: 'Could not identify the song. Try recording in a quieter environment or move closer to the speaker.' 
      });
    }

    // Save to database and return
    const song = await saveSongToDatabase(result);
    
    res.json({
      success: true,
      song: {
        id: song.id,
        title: song.title,
        artist: song.artist,
        album: song.album
      }
    });

  } catch (error) {
    console.error('[Recognition] Error:', error);
    
    // Better error messages
    if (error.message.includes('timeout')) {
      return res.status(504).json({ 
        error: 'Recognition timeout. Please try again with a clearer audio sample.' 
      });
    }
    
    if (error.message.includes('quota')) {
      return res.status(429).json({ 
        error: 'Recognition service temporarily unavailable. Please try again in a few minutes.' 
      });
    }
    
    res.status(500).json({ 
      error: 'Failed to recognize song. Please ensure the music is clear and try again.' 
    });
  }
});
```

---

## âœ… Solution 4: Audio Preprocessing

Improve audio quality before sending to recognition service:

```bash
npm install fluent-ffmpeg
```

```typescript
// server/lib/audio-processor.ts

import ffmpeg from 'fluent-ffmpeg';
import { Readable } from 'stream';

export async function preprocessAudio(audioBuffer: Buffer): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const chunks: Buffer[] = [];

    ffmpeg()
      .input(Readable.from(audioBuffer))
      .inputFormat('wav')
      .audioChannels(1)           // Convert to mono
      .audioFrequency(44100)      // Standard sample rate
      .audioBitrate('128k')       // Good quality
      .audioCodec('pcm_s16le')    // Standard PCM
      .format('wav')
      .on('error', reject)
      .on('end', () => resolve(Buffer.concat(chunks)))
      .pipe()
      .on('data', (chunk) => chunks.push(chunk));
  });
}

// Use in recognition
export async function recognizeSong(audioBuffer: Buffer): Promise<RecognitionResult> {
  // Preprocess audio
  const processedAudio = await preprocessAudio(audioBuffer);
  
  // Then send to recognition service
  return await recognizeWithAudD(processedAudio);
}
```

---

## âœ… Solution 5: Client-Side Audio Optimization

```typescript
// client/src/lib/audio-converter.ts

export async function convertToWAV(audioBlob: Blob): Promise<Blob> {
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();
  const arrayBuffer = await audioBlob.arrayBuffer();
  const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

  // Normalize audio levels
  const channelData = audioBuffer.getChannelData(0);
  let max = 0;
  
  for (let i = 0; i < channelData.length; i++) {
    max = Math.max(max, Math.abs(channelData[i]));
  }

  // Normalize if audio is too quiet
  if (max > 0 && max < 0.5) {
    const gain = 0.8 / max;
    for (let i = 0; i < channelData.length; i++) {
      channelData[i] *= gain;
    }
    console.log('[AudioConverter] Normalized audio by', gain.toFixed(2));
  }

  // Convert to WAV with optimal settings
  const wav = audioBufferToWav(audioBuffer, {
    sampleRate: 44100,  // Standard rate for music recognition
    bitDepth: 16        // Standard bit depth
  });

  return new Blob([wav], { type: 'audio/wav' });
}
```

---

## âœ… Solution 6: Environment Variables

```bash
# .env

# Primary service (choose one)
AUDD_API_KEY=your-audd-key              # https://audd.io
# or
ACRCLOUD_ACCESS_KEY=your-key            # https://www.acrcloud.com
ACRCLOUD_ACCESS_SECRET=your-secret
ACRCLOUD_HOST=identify-eu-west-1.acrcloud.com
# or
RAPIDAPI_KEY=your-rapidapi-key          # https://rapidapi.com/apidojo/api/shazam

# Recommended: Get all three for best results
```

---

## ðŸŽ¯ Quick Wins (Implement These First)

### 1. Increase Recording Duration
```typescript
const RECORDING_DURATION = 12; // Was 5
```

### 2. Better Error Messages
```typescript
error: 'Failed to recognize. Try moving closer to the speaker.'
```

### 3. Add Retries
```typescript
let attempts = 0;
while (attempts < 3) {
  try {
    return await recognizeSong(audio);
  } catch (error) {
    attempts++;
    await sleep(1000);
  }
}
```

---

## ðŸ“Š Recognition Success Tips

**For Users (Show in UI):**
- ðŸ”Š Play music at medium-high volume
- ðŸ¤« Reduce background noise
- ðŸ“± Hold phone closer to speaker
- â±ï¸ Record during the chorus (most recognizable)
- ðŸŽµ Avoid live recordings or covers

**Technical:**
- Use 10-15 second samples (not 5)
- Record in stereo at 48kHz
- Normalize audio levels
- Use multiple recognition services as fallbacks
- Implement retry logic with exponential backoff

---

## ðŸ”§ Debug Current Service

Check what's actually failing:

```typescript
// server/lib/music-recognition.ts

export async function recognizeSong(audioBuffer: Buffer) {
  console.log('[Recognition] Audio size:', audioBuffer.length);
  console.log('[Recognition] API Key configured:', !!process.env.AUDD_API_KEY);
  
  try {
    const response = await axios.post('https://api.audd.io/', formData, {
      timeout: 15000,
      validateStatus: () => true  // Log all responses
    });

    console.log('[Recognition] API Response:', {
      status: response.status,
      data: response.data
    });

    // Check specific error
    if (response.data.error) {
      console.error('[Recognition] API Error:', response.data.error.error_message);
    }

    return response.data;
  } catch (error) {
    console.error('[Recognition] Request failed:', error.message);
    throw error;
  }
}
```

---

## ðŸŽ¯ Recommended Implementation

1. **Increase recording to 12 seconds**
2. **Add AudD as primary + ACRCloud as fallback**
3. **Implement retry logic (3 attempts)**
4. **Better error messages for users**
5. **Audio normalization on client**

This should increase your recognition success rate from ~30% to ~80-90%! ðŸŽµâœ¨