# üéµ Auto-Scrolling Synced Lyrics (Like Musixmatch/Tidal)

## What You Want

**Features:**
- ‚úÖ Lyrics auto-scroll as song plays
- ‚úÖ Current line highlighted
- ‚úÖ Smooth scrolling animation
- ‚úÖ Tap to seek to specific line
- ‚úÖ Manual scroll pauses auto-scroll temporarily

---

## üèóÔ∏è Architecture

### Data Structure

Each lyric line needs a timestamp:

```typescript
interface LyricLine {
  text: string;
  translatedText?: string;
  phoneticGuide?: string;
  startTime: number;  // in seconds (e.g., 12.5)
  endTime?: number;   // optional
}

// Example:
const lyrics: LyricLine[] = [
  { 
    text: "El d√≠a de mi suerte",
    translatedText: "The day of my luck",
    phoneticGuide: "ehl deeah deh mee swehr-teh",
    startTime: 0.5,
    endTime: 3.2
  },
  {
    text: "Que sepas lo mucho que te quiero",
    translatedText: "That you know how much I love you",
    phoneticGuide: "keh seh-pahs loh moo-choh keh teh kee-eh-roh",
    startTime: 3.2,
    endTime: 6.8
  },
  // ...
];
```

---

## ‚úÖ Implementation

### Step 1: Add Audio Element with Time Tracking

```typescript
import { useRef, useState, useEffect } from 'react';

export default function LyricsPage() {
  const [currentTime, setCurrentTime] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentLineIndex, setCurrentLineIndex] = useState(-1);
  const [autoScroll, setAutoScroll] = useState(true);
  
  const audioRef = useRef<HTMLAudioElement>(null);
  const lyricsContainerRef = useRef<HTMLDivElement>(null);
  const lineRefs = useRef<(HTMLDivElement | null)[]>([]);

  // Track audio time
  useEffect(() => {
    const audio = audioRef.current;
    if (!audio) return;

    const handleTimeUpdate = () => {
      setCurrentTime(audio.currentTime);
    };

    const handlePlay = () => setIsPlaying(true);
    const handlePause = () => setIsPlaying(false);

    audio.addEventListener('timeupdate', handleTimeUpdate);
    audio.addEventListener('play', handlePlay);
    audio.addEventListener('pause', handlePause);

    return () => {
      audio.removeEventListener('timeupdate', handleTimeUpdate);
      audio.removeEventListener('play', handlePlay);
      audio.removeEventListener('pause', handlePause);
    };
  }, []);

  // Find current line based on time
  useEffect(() => {
    const currentIndex = lyrics.findIndex((line, index) => {
      const nextLine = lyrics[index + 1];
      return currentTime >= line.startTime && 
             (!nextLine || currentTime < nextLine.startTime);
    });

    if (currentIndex !== currentLineIndex) {
      setCurrentLineIndex(currentIndex);
    }
  }, [currentTime, lyrics]);

  // Auto-scroll to current line
  useEffect(() => {
    if (!autoScroll || currentLineIndex === -1) return;

    const currentLineElement = lineRefs.current[currentLineIndex];
    const container = lyricsContainerRef.current;

    if (currentLineElement && container) {
      const containerHeight = container.clientHeight;
      const lineTop = currentLineElement.offsetTop;
      const lineHeight = currentLineElement.clientHeight;
      
      // Scroll to center the current line
      const scrollTo = lineTop - (containerHeight / 2) + (lineHeight / 2);

      container.scrollTo({
        top: scrollTo,
        behavior: 'smooth'
      });
    }
  }, [currentLineIndex, autoScroll]);

  // Detect manual scroll (pause auto-scroll temporarily)
  useEffect(() => {
    const container = lyricsContainerRef.current;
    if (!container) return;

    let scrollTimeout: NodeJS.Timeout;
    
    const handleScroll = () => {
      // User scrolled manually, pause auto-scroll
      setAutoScroll(false);
      
      // Resume auto-scroll after 3 seconds of no scrolling
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        setAutoScroll(true);
      }, 3000);
    };

    container.addEventListener('scroll', handleScroll, { passive: true });

    return () => {
      container.removeEventListener('scroll', handleScroll);
      clearTimeout(scrollTimeout);
    };
  }, []);

  return (
    <>
      {/* Hidden audio element */}
      <audio 
        ref={audioRef}
        src={audioUrl}
        preload="metadata"
      />

      {/* Lyrics container */}
      <div 
        ref={lyricsContainerRef}
        className="flex-1 overflow-y-auto relative"
      >
        {lyrics.map((line, index) => (
          <div
            key={index}
            ref={(el) => (lineRefs.current[index] = el)}
            onClick={() => handleLineClick(line.startTime)}
            className={cn(
              "px-4 py-3 transition-all duration-300 cursor-pointer",
              "hover:bg-muted/50",
              index === currentLineIndex && [
                "bg-primary/10",
                "scale-105",
                "font-semibold",
                "text-primary"
              ],
              index !== currentLineIndex && [
                "text-muted-foreground",
                "opacity-60"
              ]
            )}
          >
            {/* Original text */}
            <div className="text-lg">{line.text}</div>
            
            {/* Translation */}
            {line.translatedText && (
              <div className="text-sm mt-1 opacity-70">
                {line.translatedText}
              </div>
            )}
            
            {/* Phonetic guide */}
            {line.phoneticGuide && (
              <div className="text-xs mt-1 font-mono opacity-50">
                {line.phoneticGuide}
              </div>
            )}
          </div>
        ))}
      </div>
    </>
  );
}
```

---

### Step 2: Add Seek on Line Click

```typescript
const handleLineClick = (startTime: number) => {
  if (audioRef.current) {
    audioRef.current.currentTime = startTime;
    
    // Auto-play if paused
    if (!isPlaying) {
      audioRef.current.play();
    }
    
    // Re-enable auto-scroll
    setAutoScroll(true);
  }
};
```

---

### Step 3: Get Timestamps from Recognition

When you recognize a song, the API should return lyrics with timestamps:

```typescript
interface RecognitionResult {
  songId: string;
  title: string;
  artist: string;
  audioUrl: string;
  lyrics: LyricLine[];  // With timestamps
  previewOffset?: number;  // Where preview starts
}

// Example recognition response:
{
  "songId": "abc123",
  "title": "El D√≠a de Mi Suerte",
  "artist": "Willie Col√≥n",
  "audioUrl": "https://preview.spotify.com/...",
  "previewOffset": 30,  // Preview starts at 30s in the song
  "lyrics": [
    {
      "text": "El d√≠a de mi suerte",
      "startTime": 30.5,
      "endTime": 33.2
    },
    // ...
  ]
}
```

---

### Step 4: Backend - Get Synced Lyrics

Update your recognition endpoint to fetch synced lyrics:

```typescript
// server/routes.ts

app.post('/api/recognize', async (req, res) => {
  // ... existing recognition code ...
  
  const songId = recognitionResult.songId;
  
  // Try to get synced lyrics from Musixmatch API
  const syncedLyrics = await getSyncedLyrics(songId);
  
  if (syncedLyrics) {
    return res.json({
      ...recognitionResult,
      lyrics: syncedLyrics,
      hasSyncedLyrics: true
    });
  }
  
  // Fallback to plain lyrics with estimated timestamps
  const plainLyrics = await getPlainLyrics(songId);
  const estimatedTimestamps = estimateTimestamps(plainLyrics, duration);
  
  return res.json({
    ...recognitionResult,
    lyrics: estimatedTimestamps,
    hasSyncedLyrics: false
  });
});

// Estimate timestamps if synced lyrics not available
function estimateTimestamps(lyrics: string[], durationSeconds: number) {
  const timePerLine = durationSeconds / lyrics.length;
  
  return lyrics.map((text, index) => ({
    text,
    startTime: index * timePerLine,
    endTime: (index + 1) * timePerLine
  }));
}
```

---

### Step 5: Add Progress Bar (Optional)

Show a progress indicator on the current line:

```typescript
<div className="relative">
  {/* Line content */}
  <div>{line.text}</div>
  
  {/* Progress bar for current line */}
  {index === currentLineIndex && line.endTime && (
    <div className="absolute bottom-0 left-0 right-0 h-0.5 bg-primary/20">
      <div 
        className="h-full bg-primary transition-all duration-100"
        style={{
          width: `${getLineProgress(line, currentTime)}%`
        }}
      />
    </div>
  )}
</div>

// Calculate progress within current line
function getLineProgress(line: LyricLine, currentTime: number): number {
  if (!line.endTime) return 0;
  
  const duration = line.endTime - line.startTime;
  const elapsed = currentTime - line.startTime;
  
  return Math.min(100, Math.max(0, (elapsed / duration) * 100));
}
```

---

### Step 6: Add Controls

```typescript
<div className="flex items-center justify-between px-4 py-2 border-t">
  {/* Auto-scroll toggle */}
  <Button
    variant={autoScroll ? "default" : "outline"}
    size="sm"
    onClick={() => setAutoScroll(!autoScroll)}
  >
    <ScrollText className="h-4 w-4 mr-2" />
    Auto-scroll {autoScroll ? 'On' : 'Off'}
  </Button>
  
  {/* Play/Pause */}
  <Button
    size="sm"
    onClick={() => {
      if (isPlaying) {
        audioRef.current?.pause();
      } else {
        audioRef.current?.play();
      }
    }}
  >
    {isPlaying ? (
      <Pause className="h-4 w-4" />
    ) : (
      <Play className="h-4 w-4" />
    )}
  </Button>
</div>
```

---

## üé® Enhanced Styling

```tsx
<div
  className={cn(
    "px-4 py-4 transition-all duration-500 cursor-pointer border-l-4",
    index === currentLineIndex ? [
      // Current line - prominent
      "border-l-primary bg-gradient-to-r from-primary/10 to-transparent",
      "scale-105 text-foreground font-semibold",
      "shadow-lg"
    ] : index === currentLineIndex - 1 || index === currentLineIndex + 1 ? [
      // Adjacent lines - medium emphasis
      "border-l-transparent opacity-70 text-foreground/80"
    ] : [
      // Other lines - subtle
      "border-l-transparent opacity-40 text-muted-foreground"
    ]
  )}
>
  {/* Line content */}
</div>
```

---

## üì± Mobile Optimizations

### Prevent Scroll Bounce

```typescript
useEffect(() => {
  const container = lyricsContainerRef.current;
  if (!container) return;

  // Prevent rubber-band scrolling on iOS
  container.style.overscrollBehavior = 'contain';
  
  return () => {
    container.style.overscrollBehavior = 'auto';
  };
}, []);
```

### Add Haptic Feedback (Capacitor)

```typescript
import { Haptics, ImpactStyle } from '@capacitor/haptics';

// When line changes
useEffect(() => {
  if (currentLineIndex !== -1) {
    Haptics.impact({ style: ImpactStyle.Light });
  }
}, [currentLineIndex]);
```

---

## üîÑ Fallback: No Timestamps Available

If synced lyrics aren't available, show a message:

```tsx
{!hasSyncedLyrics && (
  <div className="px-4 py-2 bg-yellow-500/10 border-l-4 border-yellow-500 text-sm">
    <AlertTriangle className="inline h-4 w-4 mr-2" />
    Synced lyrics not available. Showing plain lyrics.
  </div>
)}
```

---

## üéØ Complete Flow

1. **Song Recognition** ‚Üí Get song ID, audio URL, lyrics with timestamps
2. **Load Audio** ‚Üí Hidden `<audio>` element plays preview
3. **Track Time** ‚Üí `timeupdate` event updates `currentTime`
4. **Find Current Line** ‚Üí Compare `currentTime` with `startTime`
5. **Auto-Scroll** ‚Üí Scroll container to center current line
6. **Highlight** ‚Üí Apply styles to current line
7. **User Interaction** ‚Üí Click line to seek, scroll to pause auto-scroll

---

## üìä Data Sources for Synced Lyrics

### Option 1: Musixmatch API
- Best coverage
- High-quality timestamps
- Paid service

### Option 2: Spotify Lyrics API (Web API)
- Good for Spotify tracks
- Requires Spotify Premium

### Option 3: LRCLIB (Free)
- Community-sourced LRC files
- Free but limited coverage
- API: https://lrclib.net/api

### Option 4: Genius API + Timestamp Estimation
- Get plain lyrics from Genius
- Estimate timestamps based on song duration
- Less accurate but free

---

## üöÄ Example API Integration (LRCLIB)

```typescript
async function getSyncedLyrics(trackName: string, artistName: string, duration: number) {
  try {
    const response = await fetch(
      `https://lrclib.net/api/get?track_name=${encodeURIComponent(trackName)}&artist_name=${encodeURIComponent(artistName)}&duration=${Math.round(duration)}`
    );
    
    if (!response.ok) return null;
    
    const data = await response.json();
    
    // Parse LRC format to our format
    return parseLRCToLyrics(data.syncedLyrics);
  } catch (error) {
    console.error('Failed to get synced lyrics:', error);
    return null;
  }
}

function parseLRCToLyrics(lrcText: string): LyricLine[] {
  const lines = lrcText.split('\n');
  const lyrics: LyricLine[] = [];
  
  for (const line of lines) {
    // LRC format: [mm:ss.xx]text
    const match = line.match(/\[(\d{2}):(\d{2})\.(\d{2})\](.*)/);
    if (match) {
      const [, minutes, seconds, centiseconds, text] = match;
      const startTime = parseInt(minutes) * 60 + 
                       parseInt(seconds) + 
                       parseInt(centiseconds) / 100;
      
      lyrics.push({
        text: text.trim(),
        startTime
      });
    }
  }
  
  // Calculate endTime for each line
  for (let i = 0; i < lyrics.length - 1; i++) {
    lyrics[i].endTime = lyrics[i + 1].startTime;
  }
  
  return lyrics;
}
```

---

## ‚úÖ Features Summary

- ‚úÖ Auto-scroll follows playback
- ‚úÖ Current line highlighted and centered
- ‚úÖ Tap line to seek to that timestamp
- ‚úÖ Manual scroll pauses auto-scroll temporarily
- ‚úÖ Smooth animations
- ‚úÖ Progress bar on current line
- ‚úÖ Works with or without synced lyrics
- ‚úÖ Mobile-optimized with haptics

**This gives you a premium Musixmatch/Tidal-style experience!** üéµ‚ú®