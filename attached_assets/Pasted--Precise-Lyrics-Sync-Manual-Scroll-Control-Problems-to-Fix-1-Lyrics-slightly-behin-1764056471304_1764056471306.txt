# ðŸŽ¯ Precise Lyrics Sync + Manual Scroll Control

## Problems to Fix

1. âŒ Lyrics slightly behind music (timing offset)
2. âŒ Can't manually scroll without losing sync
3. âŒ Need background audio detection for precise sync

---

## âœ… Solution 1: Timing Offset Calibration

Lyrics often need a small offset adjustment (usually -200ms to +500ms):

```typescript
const [timingOffset, setTimingOffset] = useState(0); // milliseconds
const [currentTime, setCurrentTime] = useState(0);

// Adjust current time with offset
const adjustedTime = currentTime + (timingOffset / 1000);

// Find current line with adjusted time
useEffect(() => {
  const index = lyrics.findIndex((line, i) => {
    const nextLine = lyrics[i + 1];
    return adjustedTime >= line.startTime && 
           (!nextLine || adjustedTime < nextLine.startTime);
  });
  
  setCurrentLineIndex(index);
}, [adjustedTime, lyrics]);
```

### Add Timing Adjustment Controls

```tsx
<div className="flex items-center gap-2 px-4 py-2 border-t">
  <span className="text-xs text-muted-foreground">Sync</span>
  
  {/* Earlier */}
  <Button 
    size="sm" 
    variant="outline"
    onClick={() => setTimingOffset(prev => prev - 100)}
  >
    <ChevronLeft className="h-3 w-3" />
    <span className="text-xs ml-1">-0.1s</span>
  </Button>
  
  {/* Current offset */}
  <span className="text-xs font-mono min-w-[60px] text-center">
    {timingOffset > 0 ? '+' : ''}{(timingOffset / 1000).toFixed(1)}s
  </span>
  
  {/* Later */}
  <Button 
    size="sm" 
    variant="outline"
    onClick={() => setTimingOffset(prev => prev + 100)}
  >
    <span className="text-xs mr-1">+0.1s</span>
    <ChevronRight className="h-3 w-3" />
  </Button>
  
  {/* Reset */}
  <Button 
    size="sm" 
    variant="ghost"
    onClick={() => setTimingOffset(0)}
  >
    <RotateCcw className="h-3 w-3" />
  </Button>
</div>
```

---

## âœ… Solution 2: Manual Scroll + Auto-Resume

Allow users to scroll freely, then tap to re-sync:

```typescript
const [autoScroll, setAutoScroll] = useState(true);
const [userScrolling, setUserScrolling] = useState(false);
const scrollTimeoutRef = useRef<NodeJS.Timeout>();

// Detect manual scroll
useEffect(() => {
  const container = containerRef.current;
  if (!container) return;

  const handleScroll = (e: Event) => {
    // Only if scroll wasn't triggered by auto-scroll
    if (!autoScroll) return;
    
    // User is manually scrolling
    setUserScrolling(true);
    setAutoScroll(false);
    
    // Clear existing timeout
    if (scrollTimeoutRef.current) {
      clearTimeout(scrollTimeoutRef.current);
    }
    
    // Auto-resume after 5 seconds of no scrolling
    scrollTimeoutRef.current = setTimeout(() => {
      setUserScrolling(false);
      // Don't auto-enable, let user tap button
    }, 5000);
  };

  container.addEventListener('scroll', handleScroll, { passive: true });
  
  return () => {
    container.removeEventListener('scroll', handleScroll);
    if (scrollTimeoutRef.current) {
      clearTimeout(scrollTimeoutRef.current);
    }
  };
}, [autoScroll]);

// Auto-scroll when enabled
useEffect(() => {
  if (!autoScroll || currentLineIndex === -1) return;

  const currentLine = lineRefs.current[currentLineIndex];
  const container = containerRef.current;

  if (currentLine && container) {
    const containerHeight = container.clientHeight;
    const lineTop = currentLine.offsetTop;
    const lineHeight = currentLine.clientHeight;
    
    // Center the line (with slight upward bias for readability)
    const scrollTo = lineTop - (containerHeight / 3); // Top 1/3 instead of center

    container.scrollTo({
      top: scrollTo,
      behavior: 'smooth'
    });
  }
}, [currentLineIndex, autoScroll]);
```

### Add Sync Control Button

```tsx
{/* Show when auto-scroll is disabled */}
{!autoScroll && (
  <Button
    className="fixed bottom-20 right-4 z-50 shadow-lg"
    onClick={() => setAutoScroll(true)}
    size="lg"
  >
    <Play className="h-5 w-5 mr-2" />
    Resume Auto-Scroll
  </Button>
)}

{/* Or as a toggle in header */}
<Button
  variant={autoScroll ? "default" : "outline"}
  size="sm"
  onClick={() => setAutoScroll(!autoScroll)}
>
  <ScrollText className="h-4 w-4 mr-2" />
  {autoScroll ? 'Auto' : 'Manual'}
</Button>
```

---

## âœ… Solution 3: Background Audio Detection (Advanced)

Use Web Audio API to detect actual audio playback and sync with it:

```typescript
import { useEffect, useRef, useState } from 'react';

function useAudioAnalyzer() {
  const [audioContext] = useState(() => new AudioContext());
  const analyzerRef = useRef<AnalyserNode | null>(null);
  const [volume, setVolume] = useState(0);

  useEffect(() => {
    // Request microphone access
    navigator.mediaDevices.getUserMedia({ audio: true })
      .then(stream => {
        const source = audioContext.createMediaStreamSource(stream);
        const analyzer = audioContext.createAnalyser();
        analyzer.fftSize = 256;
        
        source.connect(analyzer);
        analyzerRef.current = analyzer;
        
        // Detect audio peaks
        const dataArray = new Uint8Array(analyzer.frequencyBinCount);
        
        const detectAudio = () => {
          analyzer.getByteFrequencyData(dataArray);
          const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
          setVolume(average);
          requestAnimationFrame(detectAudio);
        };
        
        detectAudio();
      })
      .catch(err => {
        console.error('Microphone access denied:', err);
      });

    return () => {
      audioContext.close();
    };
  }, []);

  return { volume };
}

// In your component:
const { volume } = useAudioAnalyzer();

// Detect beats/onsets to sync lyrics
useEffect(() => {
  if (volume > 100) { // Threshold for audio detection
    // Audio is playing, ensure sync
  }
}, [volume]);
```

### Better Approach: Audio Fingerprinting

Use AudD or ACRCloud to continuously match what's playing:

```typescript
async function detectCurrentTimestamp(audioBuffer: ArrayBuffer) {
  const formData = new FormData();
  formData.append('audio', new Blob([audioBuffer]));
  
  const response = await fetch('https://api.audd.io/', {
    method: 'POST',
    body: formData
  });
  
  const result = await response.json();
  
  return {
    songId: result.result.song_id,
    timestamp: result.result.timecode // Where in song
  };
}

// Continuously sample audio every 5 seconds
useEffect(() => {
  const interval = setInterval(async () => {
    // Record 5 seconds of audio from microphone
    const audioBlob = await recordAudio(5000);
    
    // Detect timestamp
    const { timestamp } = await detectCurrentTimestamp(audioBlob);
    
    // Adjust current time to match
    if (Math.abs(currentTime - timestamp) > 1) {
      setCurrentTime(timestamp);
    }
  }, 5000);
  
  return () => clearInterval(interval);
}, []);
```

---

## âœ… Solution 4: Tidal-Style Implementation

Combine all features for the best experience:

```typescript
export default function SyncedLyrics() {
  // State
  const [currentTime, setCurrentTime] = useState(0);
  const [currentLineIndex, setCurrentLineIndex] = useState(-1);
  const [autoScroll, setAutoScroll] = useState(true);
  const [timingOffset, setTimingOffset] = useState(0);
  const [showSyncButton, setShowSyncButton] = useState(false);
  
  // Refs
  const containerRef = useRef<HTMLDivElement>(null);
  const lineRefs = useRef<(HTMLDivElement | null)[]>([]);
  const audioRef = useRef<HTMLAudioElement>(null);
  const lastScrollByUser = useRef(false);
  
  // Track audio time
  useEffect(() => {
    const audio = audioRef.current;
    if (!audio) return;

    const handleTimeUpdate = () => {
      setCurrentTime(audio.currentTime);
    };

    audio.addEventListener('timeupdate', handleTimeUpdate);
    return () => audio.removeEventListener('timeupdate', handleTimeUpdate);
  }, []);

  // Calculate adjusted time
  const adjustedTime = currentTime + (timingOffset / 1000);

  // Find current line
  useEffect(() => {
    const index = lyrics.findIndex((line, i) => {
      const nextLine = lyrics[i + 1];
      return adjustedTime >= line.startTime && 
             (!nextLine || adjustedTime < nextLine.startTime);
    });

    if (index !== currentLineIndex) {
      setCurrentLineIndex(index);
    }
  }, [adjustedTime, lyrics]);

  // Auto-scroll logic
  useEffect(() => {
    if (!autoScroll || currentLineIndex === -1 || lastScrollByUser.current) {
      return;
    }

    const currentLine = lineRefs.current[currentLineIndex];
    const container = containerRef.current;

    if (currentLine && container) {
      const containerHeight = container.clientHeight;
      const lineTop = currentLine.offsetTop;
      const lineHeight = currentLine.clientHeight;
      
      // Position line at 1/3 from top (easier to read ahead)
      const targetScroll = lineTop - containerHeight / 3;
      const currentScroll = container.scrollTop;
      
      // Only scroll if significantly different (prevents jitter)
      if (Math.abs(targetScroll - currentScroll) > 20) {
        container.scrollTo({
          top: targetScroll,
          behavior: 'smooth'
        });
      }
    }
  }, [currentLineIndex, autoScroll]);

  // Detect user scroll
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    let scrollTimeout: NodeJS.Timeout;
    let lastScrollTop = container.scrollTop;

    const handleScroll = () => {
      const currentScrollTop = container.scrollTop;
      const scrollDiff = Math.abs(currentScrollTop - lastScrollTop);
      
      // Only trigger if scroll was significant (not auto-scroll jitter)
      if (scrollDiff > 30) {
        lastScrollByUser.current = true;
        setAutoScroll(false);
        setShowSyncButton(true);
        
        clearTimeout(scrollTimeout);
        
        // Reset flag after scrolling stops
        scrollTimeout = setTimeout(() => {
          lastScrollByUser.current = false;
        }, 1000);
      }
      
      lastScrollTop = currentScrollTop;
    };

    container.addEventListener('scroll', handleScroll, { passive: true });

    return () => {
      container.removeEventListener('scroll', handleScroll);
      clearTimeout(scrollTimeout);
    };
  }, []);

  return (
    <div className="flex flex-col h-full">
      {/* Lyrics Container */}
      <div 
        ref={containerRef}
        className="flex-1 overflow-y-auto relative"
      >
        {lyrics.map((line, index) => (
          <div
            key={index}
            ref={(el) => (lineRefs.current[index] = el)}
            onClick={() => {
              // Seek to this line
              if (audioRef.current) {
                audioRef.current.currentTime = line.startTime;
              }
              // Re-enable auto-scroll
              setAutoScroll(true);
              setShowSyncButton(false);
            }}
            className={cn(
              "px-6 py-4 transition-all duration-300 cursor-pointer",
              "border-l-4 relative",
              index === currentLineIndex && [
                "border-l-primary",
                "bg-gradient-to-r from-primary/10 to-transparent",
                "scale-[1.02]",
                "text-foreground font-semibold text-lg"
              ],
              index === currentLineIndex - 1 && [
                "border-l-muted",
                "opacity-70 text-base"
              ],
              index === currentLineIndex + 1 && [
                "border-l-muted", 
                "opacity-70 text-base"
              ],
              index !== currentLineIndex && 
              index !== currentLineIndex - 1 && 
              index !== currentLineIndex + 1 && [
                "border-l-transparent",
                "opacity-40 text-sm text-muted-foreground"
              ]
            )}
          >
            <div>{line.text}</div>
            
            {line.translatedText && (
              <div className="text-sm mt-1 opacity-60">
                {line.translatedText}
              </div>
            )}
            
            {/* Progress indicator on current line */}
            {index === currentLineIndex && line.endTime && (
              <div className="absolute bottom-0 left-0 right-0 h-1 bg-primary/10">
                <div 
                  className="h-full bg-primary transition-all duration-100"
                  style={{
                    width: `${Math.min(100, Math.max(0, 
                      ((adjustedTime - line.startTime) / 
                       (line.endTime - line.startTime)) * 100
                    ))}%`
                  }}
                />
              </div>
            )}
          </div>
        ))}
      </div>

      {/* Sync Controls */}
      <div className="border-t bg-background/95 backdrop-blur">
        <div className="flex items-center justify-between px-4 py-2">
          {/* Timing adjustment */}
          <div className="flex items-center gap-2">
            <span className="text-xs text-muted-foreground">Sync:</span>
            <Button 
              size="sm" 
              variant="ghost"
              className="h-7 w-7 p-0"
              onClick={() => setTimingOffset(prev => prev - 100)}
            >
              <Minus className="h-3 w-3" />
            </Button>
            <span className="text-xs font-mono w-12 text-center">
              {timingOffset > 0 ? '+' : ''}{(timingOffset / 1000).toFixed(1)}s
            </span>
            <Button 
              size="sm" 
              variant="ghost"
              className="h-7 w-7 p-0"
              onClick={() => setTimingOffset(prev => prev + 100)}
            >
              <Plus className="h-3 w-3" />
            </Button>
          </div>

          {/* Auto-scroll toggle */}
          <Button
            variant={autoScroll ? "default" : "outline"}
            size="sm"
            onClick={() => {
              setAutoScroll(!autoScroll);
              setShowSyncButton(false);
            }}
            className="h-8"
          >
            <ScrollText className="h-3.5 w-3.5 mr-1.5" />
            {autoScroll ? 'Auto' : 'Manual'}
          </Button>
        </div>
      </div>

      {/* Floating sync button */}
      {showSyncButton && !autoScroll && (
        <Button
          className="fixed bottom-24 right-4 shadow-lg z-50 animate-in slide-in-from-bottom-5"
          onClick={() => {
            setAutoScroll(true);
            setShowSyncButton(false);
          }}
          size="lg"
        >
          <Target className="h-5 w-5 mr-2" />
          Re-sync
        </Button>
      )}
      
      {/* Hidden audio element */}
      <audio ref={audioRef} src={audioUrl} />
    </div>
  );
}
```

---

## ðŸŽ¯ Best Practices

### 1. Save User's Timing Preference

```typescript
// Save to localStorage
useEffect(() => {
  if (timingOffset !== 0) {
    localStorage.setItem(`lyrics-offset-${songId}`, timingOffset.toString());
  }
}, [timingOffset, songId]);

// Load on mount
useEffect(() => {
  const saved = localStorage.getItem(`lyrics-offset-${songId}`);
  if (saved) {
    setTimingOffset(parseInt(saved));
  }
}, [songId]);
```

### 2. Prevent Jitter

```typescript
// Only scroll if difference is significant
if (Math.abs(targetScroll - currentScroll) > 20) {
  container.scrollTo({ top: targetScroll, behavior: 'smooth' });
}
```

### 3. Smart Auto-Resume

```typescript
// Resume auto-scroll when user scrolls near current line
useEffect(() => {
  if (autoScroll) return;
  
  const currentLine = lineRefs.current[currentLineIndex];
  const container = containerRef.current;
  
  if (currentLine && container) {
    const lineTop = currentLine.offsetTop;
    const scrollTop = container.scrollTop;
    const containerHeight = container.clientHeight;
    
    // If current line is visible, auto-resume
    if (lineTop >= scrollTop && lineTop <= scrollTop + containerHeight) {
      setAutoScroll(true);
      setShowSyncButton(false);
    }
  }
}, [currentLineIndex, autoScroll]);
```

---

## ðŸ“± Mobile Considerations

### Prevent Scroll Bounce

```typescript
useEffect(() => {
  const container = containerRef.current;
  if (!container) return;
  
  container.style.overscrollBehavior = 'contain';
  
  return () => {
    container.style.overscrollBehavior = 'auto';
  };
}, []);
```

### Add Haptic Feedback

```typescript
import { Haptics, ImpactStyle } from '@capacitor/haptics';

useEffect(() => {
  if (currentLineIndex !== -1) {
    Haptics.impact({ style: ImpactStyle.Light });
  }
}, [currentLineIndex]);
```

---

## ðŸŽµ Summary

**Key Features:**
- âœ… Adjustable timing offset (-/+ buttons)
- âœ… Auto-scroll with smooth centering
- âœ… Manual scroll disables auto (with visual indicator)
- âœ… Floating "Re-sync" button appears when manual
- âœ… Tap any line to seek + re-enable auto-scroll
- âœ… Progress bar on current line
- âœ… Smart transitions (don't scroll if close enough)
- âœ… Save user's timing preference per song

**For Background Audio Detection:**
- Use Web Audio API to sample microphone
- Or use audio fingerprinting (AudD, ACRCloud)
- Continuously match timestamp every 5-10 seconds
- Adjust playback time if drift detected

**This gives you Tidal/Apple Music level sync!** ðŸŽµâœ¨